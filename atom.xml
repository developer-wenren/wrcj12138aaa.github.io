<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wrcj12138aaa.github.io/</id>
    <title>闻人的技术博客</title>
    <updated>2019-10-07T06:46:01.333Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wrcj12138aaa.github.io/"/>
    <link rel="self" href="https://wrcj12138aaa.github.io//atom.xml"/>
    <subtitle>做一个终生学习者</subtitle>
    <logo>https://wrcj12138aaa.github.io//images/avatar.png</logo>
    <icon>https://wrcj12138aaa.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 闻人的技术博客</rights>
    <entry>
        <title type="html"><![CDATA[ArrayList的全面突击]]></title>
        <id>https://wrcj12138aaa.github.io//post/arraylist-de-quan-mian-tu-ji</id>
        <link href="https://wrcj12138aaa.github.io//post/arraylist-de-quan-mian-tu-ji">
        </link>
        <updated>2019-09-01T14:44:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>ArrayList 作为 Java 集合框架中最常用的类，在一般情况下，用它存储集合数据最适合不过。知其然知其所以然，为了能更好地认识和使用 ArrayList，本文将从下面几方面深入理解 ArrayList：</p>
<ul>
<li>为什么不用数组，用 ArrayList</li>
<li>ArrayList 特性的源码分析</li>
<li>Java 8 后 的 ArrayList</li>
<li>正确的 ArrayList 使用姿势</li>
</ul>
<h2 id="为什么不用数组用-arraylist">为什么不用数组，用 ArrayList。</h2>
<p>在 Java 语言中，由于普通数组受到长度限制，初始化时就需要限定数组长度，无法根据元素个数动态扩容，并且 Java 数组供开发者调用方法有限，只有取元素，获取数组长度和添加元素一些简单操作。后台在 Java 1.2 引入了强大丰富的 Collection 框架，其中用 ArrayList 来作为可动态扩容数组的列表实现来代替 Array 在日常开发的使用，ArrayList 实现所有列表的操作方法，方便开发者操作列表集合。这里我们先列举下 ArrayList 的主要特点，在后文进行一一阐述：</p>
<ul>
<li>
<p>有序存储元素</p>
</li>
<li>
<p>允许元素重复，允许存储 <code>null</code> 值</p>
</li>
<li>
<p>支持动态扩容</p>
</li>
<li>
<p>非线程安全</p>
</li>
</ul>
<p>为了更好地认识 ArrayList，我们首先来看下从 ArrayList 的UML类图：<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6k8bml5xtj318i0lg3zz.jpg" alt=""></p>
<p>从上图可以看出 ArrayList 继承了 AbstractList, 直接实现了 Cloneable, Serializable，RandomAccess 类型标志接口。</p>
<ul>
<li>AbstractList 作为列表的抽象实现，将元素的增删改查都交给了具体的子类去实现，在元素的迭代遍历的操作上提供了默认实现。</li>
<li>Cloneable 接口的实现，表示了 ArrayList 支持调用 Object 的 <code>clone</code> 方法，实现 ArrayList 的拷贝。</li>
<li>Serializable 接口实现，说明了 ArrayList 还支持序列化和反序列操作，具有固定的 <code>serialVersionUID</code> 属性值。</li>
<li>RandomAccess 接口实现，表示 ArrayList 里的元素可以被高效效率的随机访问，以下标数字的方式获取元素。实现 RandomAccess 接口的列表上在遍历时可直接使用普通的<code>for</code>循环方式，并且执行效率上给迭代器方式更高。</li>
</ul>
<h2 id="arraylist-源码分析">ArrayList 源码分析</h2>
<p>进入 ArrayList 源代码，从类的结构里很快就能看到 ArrayList 的两个重要成员变量：<code>elementData</code> 和 <code>size</code>。</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6k7ipbb2kj311a0ccgnr.jpg" alt=""></figure>
<ul>
<li><code>elementData</code> 是一个 Object 数组，存放的元素，正是外部需要存放到 ArrayList 的元素，即 ArrayList 对象维护着这个对象数组 Object[]，对外提供的增删改查以及遍历都是与这个数组有关，也因此添加到 ArrayList 的元素都是有序地存储在数组对象 <code>elementData</code> 中。</li>
<li><code>size</code> 字段表示着当前添加到 ArrayList 的元素个数，需要注意的是它必定小于等于数组对象 <code>elementData</code> 的长度。一旦当 <code>size</code> 与 <code>elementData</code> 长度相同，并且还在往列表里添加元素时，ArrayList 就会执行扩容操作，用一个更长的数组对象存储先前的元素。</li>
</ul>
<p>由于底层维护的是一个对象数组，所以向 ArrayList 集合添加的元素自然是可以重复的，允许为 <code>null</code> 的，并且它们的索引位置各不一样。</p>
<h3 id="如何扩容">如何扩容</h3>
<p>了解完 ArrayList 为何有序存储元素和元素可以重复，我们再来看下作为动态数组列表，底层扩容是如何实现的。</p>
<p>首先，要确定下扩容的时机会是在哪里，就如上面描述 <code>size</code> 字段时提到的，当 <code>size</code> 与 <code>elementData</code> 长度相同，此刻再添加一个元素到集合就会出现容量不够的情况，需要进行扩容，也就是说 ArrayList 的扩容操作发生在添加方法中，并且满足一定条件时才会发生。</p>
<p>现在我们再来看下 ArrayList 类的代码结构，可以看到有四个添加元素的方法，分为两类：添加单个元素和添加另一个集合内的所有元素。</p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6k7yqr5guj311i0qoq7u.jpg" alt=""></figure>
<p>先从简单的方法下手分析，查看 <code>add(E):boolean</code> 方法实现：</p>
<pre><code class="language-java">public boolean add(E e) {
    ensureCapacityInternal(size + 1);
    elementData[size++] = e; 
    return true;
}
</code></pre>
<p>从上面可以看出第三行代码是简单地添加单个元素，并让 <code>size</code> 递增加 1；那么扩容实现就在 <code>ensureCapacityInternal</code> 方法中，这里传入参数为 <code>size</code>+1，就是要在真正添加元素前判断添加后的元素个数，也就是集合所需要的最小容量是否会超过原数组的长度。再看下这个 <code>ensureCapacityInternal</code> 方法实现</p>
<pre><code class="language-java">private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData,minCapacity));
}
</code></pre>
<p>其内部仍有两个方法调用，首先看下比较简单的 <code>calculateCapacity</code> 方法：</p>
<pre><code class="language-java">private static int calculateCapacity(Object[] elementData, int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}
</code></pre>
<p>当 <code>elementData</code> 与 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 相等，也就是空数组时，返回一个可添加元素的默认最小容量值 <code>DEFAULT_CAPACITY</code> 对应的10 ，否则按照传入的 <code>size</code> +1 为最小容量值；执行完之后接着看 <code>ensureExplicitCapacity</code> 方法：</p>
<pre><code class="language-java">private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}
</code></pre>
<p>从代码中可以看到扩容实现在 <code>grow</code> 方法之中，并且只有当数组长度小于所需要的最小容量时执行：当数组存储元素已满，无法再存储将新加入的元素。</p>
<pre><code class="language-java">private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre>
<p>进一步跳转到 <code>grow</code> 方法的实现，可以看到第8行利用工具类方法 <code>java.util.Arrays#copyOf(T[], int)</code> ,对原有数组进行拷贝，将内部所有的元素存放到长度为 <code>newCapacity</code> 的新数组中，并将对应新数组的引用赋值给 <code>elementData</code>。此刻 ArrayList 内部引用的对象就是更新长度了的新数组，实现效果就如下图一样：<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6k9c9y18cj30zk0hqt9r.jpg" alt=""></p>
<p>现在我们再来关注下代表数组新容量的 <code>newCapacity</code> 被调整为多少。首先 <code>newCapacity</code> 通过 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code> 计算获得，使用位运算将原容量值 <code>oldCapacity</code> 通过右移一位，获得其一半的值（向下取整）, 然后加上原来的容量值，那么就是原容量值 <code>oldCapacity</code> 的1.5倍。</p>
<blockquote>
<p><code>&gt;&gt;</code>  右位运算符，会将左操作数进行右移，相当于除以2，并且向下取整，比如表达式 <code>(7 &gt;&gt; 1) == 3</code> 结果为真。</p>
</blockquote>
<p>当计算得到的 <code>newCapacity</code> 仍然小于传入最小容量值时，说明当前数组个数为空，采用默认的 <code>DEFAULT_CAPACITY</code>作为容量值分配数组。</p>
<p>额外需要注意的是还有最大数组个数的判断，<code>MAX_ARRAY_SIZE</code> 在文件对应的代码定义如下：</p>
<pre><code class="language-java">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
</code></pre>
<p>ArrayList 存储元素个数有最大限制，如果超过限制就会导致 JVM 抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>到这里 <code>java.util.ArrayList#add(E)</code> 方法的扩容逻辑就分析结束了。类似的，在其他添加元素的方法里实现内我们都可以看到 <code>ensureCapacityInternal</code> 方法的调用，在真正操作底层数组前都会进行容量的确认，容量不够则进行动态扩容。</p>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6ka4qkzpoj31xk0ekq9y.jpg" alt=""></figure>
<h3 id="序列化与反序列化">序列化与反序列化</h3>
<pre><code class="language-java">transient Object[] elementData;
</code></pre>
<p>在 ArrayList 源码看到的 <code>elementData</code> 带有关键字 <code>transient</code>，而通常 <code>transient</code> 关键字修饰了字段则表示该字段不会被序列化，但是 ArrayList 实现了序列化接口，并且提供的序列化方法 <code>writeObject</code> 与反序列化方法 <code>readObject</code> 的实现, 这是如何做到的呢？</p>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6khxdanx6j30t40kodj0.jpg" alt=""></figure>
<p>我们首先来看下 ArrayList 进行序列化的代码：</p>
<pre><code class="language-java">private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
    int expectedModCount = modCount;
    s.defaultWriteObject();

    s.writeInt(size);

    for (int i = 0; i &lt; size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
</code></pre>
<p>第4行代码首先将当前对象的非 <code>static</code> 修饰，非 <code>transient</code> 修饰的字段写出到流中；第6行将写出元素的个数作为容量。</p>
<p>接下来就是通过循环将包含的所有元素写出到流，在这一步可以看出 ArrayList 在自己实现的序列化方法中没有将无存储数据的内存空间进行序列化，节省了空间和时间。</p>
<p>同样地，在反序列化中根据读进来的流数据中获取 <code>size</code> 属性，然后进行数组的扩容，最后将流数据中读到的所有元素数据存放到持有的对象数组中。</p>
<pre><code class="language-java">private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    s.defaultReadObject();

    s.readInt(); // ignored

    if (size &gt; 0) {
        int capacity = calculateCapacity(elementData, size);
        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);
        ensureCapacityInternal(size);

        Object[] a = elementData;
        for (int i = 0; i &lt; size; i++) {
            a[i] = s.readObject();
        }
    }
}
</code></pre>
<h3 id="关于拷贝">关于拷贝</h3>
<p>针对列表元素的拷贝，ArrayList 提供自定义的 clone 实现如下：</p>
<pre><code class="language-java">public Object clone() {
  try {
    ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();
    v.elementData = Arrays.copyOf(elementData, size);
    v.modCount = 0;
    return v;
  } catch (CloneNotSupportedException e) {
    // this shouldn't happen, since we are Cloneable
    throw new InternalError(e);
  }
}
</code></pre>
<p>从上述代码可以清楚看出执行的 <code>copyOf</code> 操作是一次浅拷贝操作，原 ArrayList 对象的元素不会被拷贝一份存到新的 ArrayList 对象然后返回，它们各自的字段 <code>elementData</code> 里各位置存放的都是一样元素的引用，一旦哪个列表修改了数组中的某个元素，另一个列表也将受到影响。</p>
<h2 id="jdk-18-后的-arraylist">JDK 1.8 后的 ArrayList</h2>
<p>从源码角度分析完 ArrayList 的特性之后，我们再来看下 JDK 1.8 之后在 ArrayList 类上有什么新的变化。</p>
<h3 id="新增-removeif-方法">新增 removeIf 方法</h3>
<p><code>removeIf</code> 是 Collection 接口新增的接口方法，ArrayList 由于父类实现该接口，所以也有这个方法。<code>removeIf</code> 方法用于进行指定条件的从数组中删除元素。</p>
<pre><code class="language-java">public boolean removeIf(Predicate&lt;? super E&gt; filter){...}
</code></pre>
<p>传入一个代表条件的函数式接口参数 <code>Predicate</code>，也就是Lambda 表达式进行条件匹配，如果条件为 <code>true</code>， 则将该元素从数组中删除，例如下方代码示例：</p>
<pre><code class="language-java">List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
numbers.removeIf(i -&gt; i % 2 == 0);
System.out.println(numbers); // [1, 3, 5, 7, 9]
</code></pre>
<h3 id="新增-spliterator-方法">新增 spliterator 方法</h3>
<p>这个方法也是来自于 Collection 接口，ArrayList 对此方法进行了重写。该方法会返回 ListSpliterator 实例，该实例用于遍历和分离容器所存储的元素。</p>
<pre><code class="language-java">@Override
public Spliterator&lt;E&gt; spliterator() {
    return new ArrayListSpliterator&lt;&gt;(this, 0, -1, 0);
}
</code></pre>
<p>在 ArrayList 的实现中，该方法返回一个内部静态类对象 ArrayListSpliterator，通过它可以就可以集合元素进行操作。</p>
<p>它的主要操作方法有下面三种：</p>
<ul>
<li><code>tryAdvance</code> 迭代单个元素，类似于 <code>iterator.next()</code></li>
<li><code>forEachRemaining</code> 迭代剩余元素</li>
<li><code>trySplit</code> 将元素切分成两部分并行处理,但需要注意的 Spliterator 并不是线程安全的。</li>
</ul>
<p>虽然这个三个方法不常用，还是有必要了解，可以简单看下方法的使用方式</p>
<pre><code class="language-java">ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5,6));
Spliterator&lt;Integer&gt; numbers = numbers.spliterator();

numbers.tryAdvance( e -&gt; System.out.println( e ) ); // 1

numbers.forEachRemaining( e -&gt; System.out.println( e ) ); // 2 3 4 5 6

Spliterator&lt;Integer&gt; numbers2 = numbers.trySplit();

numbers.forEachRemaining( e -&gt; System.out.println( 3 ) );      //4 5 6
numbers2.forEachRemaining( e -&gt; System.out.println( 3 ) );      //1 2 3
</code></pre>
<h2 id="必会的使用姿势">必会的使用姿势</h2>
<p>接触了 ArrayList 源码和新API 之后，我们最后学习如何在平常开发中高效地使用 ArrayList。</p>
<h3 id="高效的初始化">高效的初始化</h3>
<p>ArrayList 实现了三个构造函数, 默认创建时会分配到空数组对象 <code>EMPTY_ELEMENTDATA</code>；第二个是传入一个集合类型数据进行初始化；第三个允许传入集合长度的初始化值，也就是数组长度。由于每次数组长度不够会导致扩容，重新申请更长的内存空间，并进行复制。而让我们初始化 ArrayList 指定数组初始大小，可以减少数组的扩容次数，提供性能。</p>
<pre><code class="language-java">public ArrayList(int initialCapacity) {
    if (initialCapacity &gt; 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                            initialCapacity);
    }
}

public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

public ArrayList(Collection&lt;? extends E&gt; c) {
    elementData = c.toArray();
    if ((size = elementData.length) != 0) {
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        this.elementData = EMPTY_ELEMENTDATA;
    }
}
</code></pre>
<h3 id="元素遍历">元素遍历</h3>
<p>JDK 1.8前，ArrayList 只支持3种遍历方式：迭代器遍历，普通 <code>for</code> 循环，<code>for-each</code> 增强，在 JDK1.8 引入了 Stream API 之后，同属于 Collection 集合的 ArrayList，可以使用 <code>stream.foreach()</code> 方法一个个地获取元素：</p>
<pre><code class="language-java">ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;(Arrays.asList( &quot;alex&quot;, &quot;brian&quot;, &quot;charles&quot;));
names.forEach(name -&gt; System.out.println(name)); // alex brian charles
</code></pre>
<h3 id="转换-array">转换  Array</h3>
<p>ArrayList 提供两个方法用于列表向数组的转换</p>
<pre><code class="language-java">public Object[] toArray();
public &lt;T&gt; T[] toArray(T[] a);
</code></pre>
<ol>
<li>第一个方法直接返回 Object 类型数组</li>
<li>在第二个方法中，返回数组的类型为所传入的指定数组的类型。 并且如果列表的长度符合传入的数组，将元素拷贝后数组后，则在其中返回数组。 否则，将根据传入数组的类型和列表的大小重新分配一个新数组，拷贝完成后再返回。</li>
</ol>
<p>从上述描述可以看出使用第二个方法更加合适，能保留原先类型：</p>
<pre><code class="language-java">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(4);
list.add(&quot;A&quot;);
list.add(&quot;B&quot;);
list.add(&quot;C&quot;);
list.add(&quot;D&quot;);

String[] array = list.toArray(new String[list.size()]);
System.out.println(Arrays.toString(array)); // [A, B, C, D]
</code></pre>
<h3 id="应对多线程">应对多线程</h3>
<p>在这里需要说明的是 ArrayList 本身是非线程安全的，如果需要使用线程安全的列表通常采用的方式是 <code>java.util.Collections#synchronizedList(java.util.List&lt;T&gt;)</code> 或者 使用 Vector 类代替。还有一种方式是使用并发容器类 CopyOnWriteArrayList 在多线程中使用，它底层通过创建原数组的副本来实现更新，添加等原本需同步的操作，不仅线程安全，减少了对线程的同步操作。</p>
<h3 id="应对头部结点的增删">应对头部结点的增删</h3>
<p>ArrayList是数组实现的，使用的是连续的内存空间，当有在数组头部将元素添加或者删除的时候，需要对头部以后的数据进行复制并重新排序，效率很低。针对有大量类似操作的场景，出于性能考虑，我们应该使用 LinkedList 代替。由于LinkedList 是基于链表实现，当需要操作的元素位置位于List 前半段时，就从头开始遍历，马上找到后将把元素在相应的位置进行插入或者删除操作。</p>
<h2 id="结语">结语</h2>
<p>到这里我们学习总结 ArrayList 的实现和常见使用，作为基础容器集合，越是多些了解，对我们日常使用越顺手。由于上文提到了另一个列表集合 LinkedList，它与 ArrayList 实现方式不同，使用场景也不同，将作为下一篇文章分析的集合登场，感兴趣的小伙伴欢迎关注我的微信公众号，期待更新。</p>
<figure data-type="image" tabindex="5"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6kircgfk8j30p00dwdhv.jpg" alt=""></figure>
<h2 id="参考">参考</h2>
<ul>
<li>https://www.cnblogs.com/skywang12345/p/3308556.html</li>
<li>https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html</li>
<li>https://yuqirong.me/2018/01/21/ArrayList%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</li>
<li>https://juejin.im/post/5a58aa62f265da3e4d72a51b</li>
<li>https://howtodoinjava.com/java-arraylist/</li>
<li>http://cmsblogs.com/?p=4727</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[掌握 Maven 私服]]></title>
        <id>https://wrcj12138aaa.github.io//post/20190825-掌握 Maven 私服</id>
        <link href="https://wrcj12138aaa.github.io//post/20190825-掌握 Maven 私服">
        </link>
        <updated>2019-08-25T13:30:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在 Java EE 开发中，我们使用 Maven 构建工具主要来管理项目的第三方库的依赖，以及公司内部其他项目服务的依赖，而 Maven 私服就是必不可少的一环，本文主要对 Maven 私服的三大方面进行介绍：</p>
<ul>
<li>什么是 Maven 私服</li>
<li>如何搭建 Maven 私服</li>
<li>如何使用 Maven 私服</li>
</ul>
<blockquote>
<p>本文面对的读者应有 Maven 使用经验，了解 Maven 的一些基本概念，如果不太熟悉可以参见文末的参考资料学习。</p>
</blockquote>
<h2 id="什么是-maven-私服">什么是 Maven 私服</h2>
<p>在介绍 Maven 私服之前，我们首先清楚下什么是 Maven 仓库。</p>
<p><strong>Maven 仓库：Maven 统一存储所有Maven项目依赖，插件，以及所上传项目的地方。</strong></p>
<p>并且 Maven 仓库还分成两类：本地仓库和远程仓库。</p>
<ul>
<li>本地仓库，就是我们本地电脑安装Maven后，在 配置文件 setting.xml 里 <code>localRepository</code> 所需要指定目录的那个文件夹。</li>
<li>远程仓库，就是在外部网络里（包括局域网）指定 URL 的专门存放 Java 库，Maven插件等的服务器，，例如中央仓库，就是一个典型的远程仓库，它包含了世界上绝大多数开源的 Java 库，类似的还有许多其他的公开库</li>
</ul>
<p>而本文提到的私服，就是另一种特殊的远程仓库，它通常架设在局域网内的一台服务器上，用于代理所有外部的远程仓库，并且能接受内部项目的上传和获取。</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bylbdlpij315q0myq4t.jpg" alt=""></figure>
<p>而这些仓库又有是什么用呢？当 Maven 项目需要依赖一些其他项目的 Java 库时，Maven 首先会在本地仓库查找，如果存在对应的库，就直接使用；如果本地仓库不存在，Maven 就会去远程仓库查找，找到对应的 Java 库后下载到本地仓库再使用，以便于下次需要该Java库时，直接使用缓存在本地仓库的依赖库即可，省去了重复通过网络查找并下载的时间，对于 Maven 插件也是同样的过程。</p>
<p>通常情况下，中央仓库是Maven 默认的远程仓库，而当引入了私服后，本地仓库查找结束未找到所需要的依赖库时，就先从私服仓库开始查找，仍未找到的话，最后再去中央仓库查找，具体过程可以参考下图：</p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bzczhk5zj31bq0kgdia.jpg" alt="image-20190825155914631"></figure>
<p>在这里我们再看下私服的作用有哪些：</p>
<ul>
<li>内网访问，节省外网带宽。</li>
<li>一次外网下载，内网所有用户就可以只下载私服缓存，加速 Maven 项目构建。</li>
<li>允许上传和下载私有库，并且不被外部访问，更加安全。</li>
<li>减少外部网络因素，提供项目构建的稳定性。</li>
<li>方便内部项目服务的依赖引用，而不需要其他项目的完整源代码。</li>
</ul>
<p>这里对最后一小点的作用添加下具体描述：当我们有独立的两个Maven 项目，比如订单服务项目和会员服务项目，其中订单服务项目需要会员服务，依赖会员服务的 API 包，通过私服可以将编译后的会员服务的 API 包上传，然后订单服务程序直接下载引用私服上的会员服务 API 包即可，这样就不需要导入会员服务项目代码，也不用关心会员服务具体实现了，起到了内部服务项目轻度引用的作用，描述可参见下图。</p>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c0ax37pcj30pw0jc0ud.jpg" alt=""></figure>
<h2 id="搭建-maven-私服">搭建 Maven 私服</h2>
<p>了解 Maven 私服之后，我们进一步学习。我们首先来搭建一个 Maven 私服。在这里我们使用最流行的开源 Maven 仓库管理软件 -  Nexus，来快速搭建 Maven 私服，传统的搭建方式为在 Nexus 官网上下载开源版的 Nexus OSS 进行安装：https://www.sonatype.com/nexus-repository-oss。而本文将采用 Docker 方式安装 Nexus，不仅快速简单，而占用更少的机器资源。</p>
<blockquote>
<p>如果对 Docker 不熟悉的同学，可以参见 <a href="https://juejin.im/post/5d4522c1f265da03e05af5f5?utm_source=gold_browser_extension%23heading-34">10分钟快速掌握Docker必备基础知识</a> 学习了解下，简单使用 Docker 也是十分容易的。</p>
</blockquote>
<h3 id="下载-nexus-镜像">下载 Nexus 镜像</h3>
<p>在终端控制台上使用 Docker 指令下载 Nexus 官方提供的Docker 镜像：<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6cahq8wslj311s03wt8p.jpg" alt=""></p>
<p>看到下图结果时，就表示镜像下载完成，可以通过 <code>docker images</code> 查看。</p>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c0zl1pbbj310q0aqgn6.jpg" alt="image-20190825165531217"></figure>
<h3 id="启动-nexus-容器">启动 Nexus 容器</h3>
<p>使用下方指令启动 Nexus 容器：<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6cahdg9jtj31kw05awf6.jpg" alt=""></p>
<p>在这里对输入的 Docker 指令的参数进行简单的说明：</p>
<ul>
<li>
<p><code>-d</code> 表示让容器后台运行。</p>
</li>
<li>
<p><code>-p 8081:8081</code> 表示了容器启动时开放内部端口 8081（后者的8081） 映射主机端口的 8081 ，即通过 <code>localhost:8081</code>  可以访问到 Nexus 容器所提供的服务。</p>
</li>
<li>
<p><code>-v /Users/One/Desktop/Nexus/nexus-data:/nexus-data</code> 表示将容器内部 <code>/var/nexus-data</code> 挂载到当前主机的指定目录，需要注意的是，<code>-v</code> 指定的外部路径必须为全路径。</p>
</li>
<li>
<p><code>--restart=always</code> 比较简单，表示当 docker 服务启动时，该容器也跟着启动。</p>
</li>
</ul>
<p>执行上述指令后，稍等片刻，访问 <code>http://localhost:8081/</code> ，看到对应的 Nexus 后台就表示私服安装完成了，是不是很简单呢。<br>
<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c1hyrynij32fu0p2tbx.jpg" alt=""></p>
<blockquote>
<p>容器启动过程中，由于机器配置的不同，可能会出现启动慢的情况，只需耐心等待即可。</p>
</blockquote>
<p>启动完成后，我们可以在所挂载的本机目录下查看 Nexus 容器运行产生的文件。</p>
<figure data-type="image" tabindex="5"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6c9t93pizj30xy07gq3i.jpg" alt=""></figure>
<h2 id="配置-maven-私服">配置 Maven 私服</h2>
<p>私服安装之后，我们首先进行登录操作，点击页面左上角的 Sign In 按钮，就会出现和下图一样的提示：</p>
<figure data-type="image" tabindex="6"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c23iu75mj31hu0u0jub.jpg" alt=""></figure>
<p>说明了 Nexus 默认登录账号为 admin，并且密码位于文件 <code>/nexus-data/admin.password</code> 下，我们只需在本地配置的挂载目录下查看该文件即可。</p>
<figure data-type="image" tabindex="7"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c26l36ejj30zw04sgm9.jpg" alt=""></figure>
<p>输入默认的账号密码之后成功登录之后，Nexus 就会强制要求修改 admin 的密码,并且设置基本访问权限，完成之后就正式进入了 Nexus 私服后台。</p>
<figure data-type="image" tabindex="8"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c2gijrt2j32fk0icdj4.jpg" alt=""></figure>
<p>这里简单对界面元素进行介绍：</p>
<ol>
<li>默认的浏览界面，可以搜索查看仓库的组件，以及进行上传操作。</li>
<li>用于管理私服程序的配置。</li>
<li>账户信息查看，允许修改密码。</li>
</ol>
<p>进入私服程序的配置界面，我们需要对默认配置进行几点调整。</p>
<h3 id="中央仓库的代理路径设置">中央仓库的代理路径设置</h3>
<p>将私服配置里中央仓库的代理仓库路径更新为<a href="https://maven.aliyun.com/mvn/view">阿里云仓库</a>提供的代理地址：https://maven.aliyun.com/repository/central  这样一来可以更快速地访问在中央仓库上所需要的依赖和插件。</p>
<figure data-type="image" tabindex="9"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c2pxiw3jj31ac0u0k12.jpg" alt=""></figure>
<h3 id="新建自定义的仓库">新建自定义的仓库</h3>
<p>点击<code>Create repository</code>,然后选择类型为 <code>maven2(hosted)</code></p>
<figure data-type="image" tabindex="10"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c33pl9hzj317m0rmtbj.jpg" alt=""></figure>
<p>然后输入仓库名称 private-release，并在 Version policy 一栏中选择 Release，表示这个仓库的存储依赖为正式发布的组件，然后在 Deployment policy 一栏中选择 Allow redeploy，允许部署和更新私服上的组件。</p>
<figure data-type="image" tabindex="11"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c359czrej30zq0u0adq.jpg" alt=""></figure>
<p>最后点击蓝色按钮-<code>Create repository</code> 之后，就可以在仓库列表看到自定义的仓库了，有了 release 仓库，我们再按照同样方式操作添加一个 snapshot 仓库，只需在  Version policy  一栏调整为 Snapshot 即可。</p>
<figure data-type="image" tabindex="12"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c3cg9wuhj329k0pkn51.jpg" alt=""></figure>
<h3 id="添加角色">添加角色</h3>
<p>Nexus 默认只有两种角色：<code>nx-anonymous</code> 和 <code>nx-admin</code>，前者只有浏览的权限，后者为管理员权限，一般情况下，我们还需要正对开发人员创建个角色。点击 <code>Create Role</code>，添加一个 Role ID 为 <code>developer</code> 的自定义角色,  并且只添加自定义仓库的使用权限，删除操作除外。</p>
<figure data-type="image" tabindex="13"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c7nbl8q6j312d0u07h1.jpg" alt=""></figure>
<p>保存之后，新增的角色就展示在列表中，有了角色，就可以关联用户，进行权限分配了。</p>
<figure data-type="image" tabindex="14"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c4msmur8j31w80l6gpf.jpg" alt="image-20190825190139940"></figure>
<h3 id="添加用户">添加用户</h3>
<p>跟权限类似，默认的用户只有两种：<code>admin</code> 和 anonymous，我们同样需要创建属于开发者的用户对象。点击 <code>Create local user</code>，填入用户名，密码等必填信息之后，关联我们先前的创建的角色，并保存即可。</p>
<figure data-type="image" tabindex="15"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c4r9flvqj316e0u0ahw.jpg" alt=""></figure>
<p>用户创建完成之后，我们就可以用新的用户登录私服，查看对应权限的内容了，例如我们用新建的用户登录，所能操作的只有查看和搜索自定义的私服仓库。</p>
<figure data-type="image" tabindex="16"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c4txtbt8j32fi0gediz.jpg" alt=""></figure>
<p>这样一来我们就创建好了自己的私服仓库，配置完成之后，开发者就可以在 Maven 项目开发中使用了。</p>
<h2 id="使用-maven-私服">使用 Maven 私服</h2>
<p>有了私服和用于开发的账号，我们就需要在本地 Maven 配置文件 setting.xml 进行关联。</p>
<p>设置 server 账户信息：<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6caenutlsj311s0j640d.jpg" alt=""></p>
<p>设置私服仓库地址：（这里的地址，可以通过 Nexus 后台上仓库页面的 <code>cpoy</code> 按钮自动复制得到）<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6caek5x1mj313c0ri777.jpg" alt=""></p>
<h3 id="maven-项目部署到私服">Maven 项目部署到私服</h3>
<p>配置完成后，我们可以创建一个Maven工程，尝试下打包到 Maven 私服。利用 IDE 快速生成 Maven 项目，在 POM 文件添加 <code>distributionManagement</code> 节点，并且指定对应的私服仓库 id 和地址，如下：<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6cafcau8cj313e0u0jv6.jpg" alt=""></p>
<p>最后只要执行部署命令  <code>mvn clean deploy</code> 或者利用 IDE 的 部署插件即可，当控制台出现 <code>BUILD SUCCESS</code> ，如下图类似时则说明部署完成。</p>
<figure data-type="image" tabindex="17"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6c7z3lna1j31fl0u0156.jpg" alt=""></figure>
<p>从日志上可以看出，我们的项目上传都了 private- snapshot 仓库下，此时我们可以在私服网站上的  private- snapshot 仓库查看到上传的 jar。</p>
<figure data-type="image" tabindex="18"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6c83m7uozj316e0jo402.jpg" alt=""></figure>
<blockquote>
<p>如果部署过程中出现如下提示：带有 <code>Access denied to</code> 则说明在 setting.xml 配置的用户权限不足，无法将 jar 部署到对应私服仓库上去。</p>
<figure data-type="image" tabindex="19"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c7kijqodj31ie08imz4.jpg" alt=""></figure>
</blockquote>
<p>需要注意的是，对于一个Maven项目而言，如果项目的版本号中有 “SNAPSHOT” 字样，则表示当前处于开发版本，Maven 会将发布到 <code>snapshotRepository</code> 节点对应地址上去。否则，Maven则认为这是一个发布版本，将程序发布到 <code>repository</code> 节点对应的地址上。由于示例项目的版本为 <code>1.0.0-SNAPSHOT</code> ，所以最终项目上传到了 <code>private-snapshot</code> 这个 Snapshot 类型的仓库下。</p>
<p>接下来如果其他项目要依赖这个 jar 时，只需要在其 POM 文件引入对应的坐标即可。</p>
<figure data-type="image" tabindex="20"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6cag20juzj311s09gt9j.jpg" alt=""></figure>
<h3 id="将第三方-jar-包部署到-maven-私服">将第三方 jar 包部署到 Maven 私服</h3>
<p>这里说到了第三方 jar 包，不是平常所提到的开源库，更多的是来自其他第三方系统的 jar 包，由于项目需要，使用项目导入的方式来很不方便，更好的处理方式就是将第三方系统的 jar 包手动上传到 Maven 私服上，需要使用的项目直接从私服仓库中拉取即可。</p>
<p>这种方式实现起来也比较方便，分为两种：可视化界面操作和命令行操作。</p>
<p>可视化界面操作：就是在 Nexus 后台上进去，执行上传操作必须要对于的上传权限才可以，一般都是管理员账号进行操作，选择仓库后进去上传页面，指定本地需要上传的项目，自定义完坐标信息保存即可。</p>
<figure data-type="image" tabindex="21"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6c99d2l6nj31dx0u0wlh.jpg" alt=""></figure>
<p>命令行方式：直接在终端输入下面指令即可：<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6cagfocvtj31kw05a3zd.jpg" alt=""></p>
<ul>
<li>-DgroupId 和 -DartifactId 构成了该jar包在 pom.xml 的坐标， 即对应依赖的 <code>groupId</code> 和 <code>artifactId</code></li>
<li>-<code>Dfile</code> 表示需要上传的jar包的绝对路径</li>
<li>-Durl 为私服仓库的url精确地址</li>
<li>-DrepositoryId 为私服仓库定义的id</li>
<li>-Dversion 指定了版本号</li>
<li>-Dpackaging 指定了打包方式</li>
</ul>
<p>当控制台日志出现 <code>BUILD SUCCESS</code> 信息时则表示打包成功，如果出现打包失败，很有可能是 Maven 配置文件里 <code>server</code> 元素下的用户权限不足导致，需要 Nexus 后台对用户角色进行上传权限的分配。</p>
<h2 id="结语">结语</h2>
<p>在 Java 企业级项目开发中，建立并维护私服是使用 Maven 必不可少的一步，本文从 Maven 的简单介绍，到快速搭建和使用来进一步掌握 Maven 私服，为后续的企业微服务架构做好铺垫。</p>
<figure data-type="image" tabindex="22"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6ca7tzjs7j30p00dw404.jpg" alt=""></figure>
<h2 id="推荐阅读">推荐阅读</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/TfA8rSwYNpW3YV_N8oLJnw">一文掌握 Spring Boot Profiles</a></li>
<li><a href="https://mp.weixin.qq.com/s/-t2hrrVMBpPmVEzDcC8J5w">如何优雅关闭 Spring Boot 应用</a></li>
<li><a href="https://mp.weixin.qq.com/s/uWRnRhH4et-XSD101Xh6LQ">需要接口管理的你了解一下？</a></li>
<li><a href="https://mp.weixin.qq.com/s/2qkNz4VPgnixXjaVYUkvvQ">Java 之 Lombok 必知必会</a></li>
<li><a href="https://mp.weixin.qq.com/s/vS36glyNoD26GL6cbNs5Qw">Java 微服务新生代之 Nacos</a></li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p>Maven入门，读完这篇就够了：https://juejin.im/post/5a4a5e2bf265da4322418d7f#heading-2</p>
</li>
<li>
<p>Maven 实战：https://book.douban.com/subject/5345682/</p>
</li>
<li>
<p>私服 maven 仓库命令上传 jar 包： https://www.jianshu.com/p/ccd7b643624c</p>
</li>
<li>
<p>What is a Maven Repository：https://medium.com/@chris.shellenbarger/what-is-a-maven-repository-6fa22991fad9</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://wrcj12138aaa.github.io//post/hello-gridea</id>
        <link href="https://wrcj12138aaa.github.io//post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>