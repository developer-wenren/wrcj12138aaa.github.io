<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wrcj12138aaa.github.io/</id>
    <title>闻人的技术博客</title>
    <updated>2019-10-07T06:57:53.154Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wrcj12138aaa.github.io/"/>
    <link rel="self" href="https://wrcj12138aaa.github.io//atom.xml"/>
    <subtitle>做一个终生学习者</subtitle>
    <logo>https://wrcj12138aaa.github.io//images/avatar.png</logo>
    <icon>https://wrcj12138aaa.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 闻人的技术博客</rights>
    <entry>
        <title type="html"><![CDATA[ArrayList的全面突击]]></title>
        <id>https://wrcj12138aaa.github.io//post/arraylist-de-quan-mian-tu-ji</id>
        <link href="https://wrcj12138aaa.github.io//post/arraylist-de-quan-mian-tu-ji">
        </link>
        <updated>2019-09-01T14:44:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>ArrayList 作为 Java 集合框架中最常用的类，在一般情况下，用它存储集合数据最适合不过。知其然知其所以然，为了能更好地认识和使用 ArrayList，本文将从下面几方面深入理解 ArrayList：</p>
<ul>
<li>为什么不用数组，用 ArrayList</li>
<li>ArrayList 特性的源码分析</li>
<li>Java 8 后 的 ArrayList</li>
<li>正确的 ArrayList 使用姿势</li>
</ul>
<h2 id="为什么不用数组用-arraylist">为什么不用数组，用 ArrayList。</h2>
<p>在 Java 语言中，由于普通数组受到长度限制，初始化时就需要限定数组长度，无法根据元素个数动态扩容，并且 Java 数组供开发者调用方法有限，只有取元素，获取数组长度和添加元素一些简单操作。后台在 Java 1.2 引入了强大丰富的 Collection 框架，其中用 ArrayList 来作为可动态扩容数组的列表实现来代替 Array 在日常开发的使用，ArrayList 实现所有列表的操作方法，方便开发者操作列表集合。这里我们先列举下 ArrayList 的主要特点，在后文进行一一阐述：</p>
<ul>
<li>
<p>有序存储元素</p>
</li>
<li>
<p>允许元素重复，允许存储 <code>null</code> 值</p>
</li>
<li>
<p>支持动态扩容</p>
</li>
<li>
<p>非线程安全</p>
</li>
</ul>
<p>为了更好地认识 ArrayList，我们首先来看下从 ArrayList 的UML类图：<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6k8bml5xtj318i0lg3zz.jpg" alt=""></p>
<p>从上图可以看出 ArrayList 继承了 AbstractList, 直接实现了 Cloneable, Serializable，RandomAccess 类型标志接口。</p>
<ul>
<li>AbstractList 作为列表的抽象实现，将元素的增删改查都交给了具体的子类去实现，在元素的迭代遍历的操作上提供了默认实现。</li>
<li>Cloneable 接口的实现，表示了 ArrayList 支持调用 Object 的 <code>clone</code> 方法，实现 ArrayList 的拷贝。</li>
<li>Serializable 接口实现，说明了 ArrayList 还支持序列化和反序列操作，具有固定的 <code>serialVersionUID</code> 属性值。</li>
<li>RandomAccess 接口实现，表示 ArrayList 里的元素可以被高效效率的随机访问，以下标数字的方式获取元素。实现 RandomAccess 接口的列表上在遍历时可直接使用普通的<code>for</code>循环方式，并且执行效率上给迭代器方式更高。</li>
</ul>
<h2 id="arraylist-源码分析">ArrayList 源码分析</h2>
<p>进入 ArrayList 源代码，从类的结构里很快就能看到 ArrayList 的两个重要成员变量：<code>elementData</code> 和 <code>size</code>。</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6k7ipbb2kj311a0ccgnr.jpg" alt=""></figure>
<ul>
<li><code>elementData</code> 是一个 Object 数组，存放的元素，正是外部需要存放到 ArrayList 的元素，即 ArrayList 对象维护着这个对象数组 Object[]，对外提供的增删改查以及遍历都是与这个数组有关，也因此添加到 ArrayList 的元素都是有序地存储在数组对象 <code>elementData</code> 中。</li>
<li><code>size</code> 字段表示着当前添加到 ArrayList 的元素个数，需要注意的是它必定小于等于数组对象 <code>elementData</code> 的长度。一旦当 <code>size</code> 与 <code>elementData</code> 长度相同，并且还在往列表里添加元素时，ArrayList 就会执行扩容操作，用一个更长的数组对象存储先前的元素。</li>
</ul>
<p>由于底层维护的是一个对象数组，所以向 ArrayList 集合添加的元素自然是可以重复的，允许为 <code>null</code> 的，并且它们的索引位置各不一样。</p>
<h3 id="如何扩容">如何扩容</h3>
<p>了解完 ArrayList 为何有序存储元素和元素可以重复，我们再来看下作为动态数组列表，底层扩容是如何实现的。</p>
<p>首先，要确定下扩容的时机会是在哪里，就如上面描述 <code>size</code> 字段时提到的，当 <code>size</code> 与 <code>elementData</code> 长度相同，此刻再添加一个元素到集合就会出现容量不够的情况，需要进行扩容，也就是说 ArrayList 的扩容操作发生在添加方法中，并且满足一定条件时才会发生。</p>
<p>现在我们再来看下 ArrayList 类的代码结构，可以看到有四个添加元素的方法，分为两类：添加单个元素和添加另一个集合内的所有元素。</p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6k7yqr5guj311i0qoq7u.jpg" alt=""></figure>
<p>先从简单的方法下手分析，查看 <code>add(E):boolean</code> 方法实现：</p>
<pre><code class="language-java">public boolean add(E e) {
    ensureCapacityInternal(size + 1);
    elementData[size++] = e; 
    return true;
}
</code></pre>
<p>从上面可以看出第三行代码是简单地添加单个元素，并让 <code>size</code> 递增加 1；那么扩容实现就在 <code>ensureCapacityInternal</code> 方法中，这里传入参数为 <code>size</code>+1，就是要在真正添加元素前判断添加后的元素个数，也就是集合所需要的最小容量是否会超过原数组的长度。再看下这个 <code>ensureCapacityInternal</code> 方法实现</p>
<pre><code class="language-java">private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData,minCapacity));
}
</code></pre>
<p>其内部仍有两个方法调用，首先看下比较简单的 <code>calculateCapacity</code> 方法：</p>
<pre><code class="language-java">private static int calculateCapacity(Object[] elementData, int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}
</code></pre>
<p>当 <code>elementData</code> 与 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 相等，也就是空数组时，返回一个可添加元素的默认最小容量值 <code>DEFAULT_CAPACITY</code> 对应的10 ，否则按照传入的 <code>size</code> +1 为最小容量值；执行完之后接着看 <code>ensureExplicitCapacity</code> 方法：</p>
<pre><code class="language-java">private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}
</code></pre>
<p>从代码中可以看到扩容实现在 <code>grow</code> 方法之中，并且只有当数组长度小于所需要的最小容量时执行：当数组存储元素已满，无法再存储将新加入的元素。</p>
<pre><code class="language-java">private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre>
<p>进一步跳转到 <code>grow</code> 方法的实现，可以看到第8行利用工具类方法 <code>java.util.Arrays#copyOf(T[], int)</code> ,对原有数组进行拷贝，将内部所有的元素存放到长度为 <code>newCapacity</code> 的新数组中，并将对应新数组的引用赋值给 <code>elementData</code>。此刻 ArrayList 内部引用的对象就是更新长度了的新数组，实现效果就如下图一样：<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6k9c9y18cj30zk0hqt9r.jpg" alt=""></p>
<p>现在我们再来关注下代表数组新容量的 <code>newCapacity</code> 被调整为多少。首先 <code>newCapacity</code> 通过 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code> 计算获得，使用位运算将原容量值 <code>oldCapacity</code> 通过右移一位，获得其一半的值（向下取整）, 然后加上原来的容量值，那么就是原容量值 <code>oldCapacity</code> 的1.5倍。</p>
<blockquote>
<p><code>&gt;&gt;</code>  右位运算符，会将左操作数进行右移，相当于除以2，并且向下取整，比如表达式 <code>(7 &gt;&gt; 1) == 3</code> 结果为真。</p>
</blockquote>
<p>当计算得到的 <code>newCapacity</code> 仍然小于传入最小容量值时，说明当前数组个数为空，采用默认的 <code>DEFAULT_CAPACITY</code>作为容量值分配数组。</p>
<p>额外需要注意的是还有最大数组个数的判断，<code>MAX_ARRAY_SIZE</code> 在文件对应的代码定义如下：</p>
<pre><code class="language-java">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
</code></pre>
<p>ArrayList 存储元素个数有最大限制，如果超过限制就会导致 JVM 抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>到这里 <code>java.util.ArrayList#add(E)</code> 方法的扩容逻辑就分析结束了。类似的，在其他添加元素的方法里实现内我们都可以看到 <code>ensureCapacityInternal</code> 方法的调用，在真正操作底层数组前都会进行容量的确认，容量不够则进行动态扩容。</p>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6ka4qkzpoj31xk0ekq9y.jpg" alt=""></figure>
<h3 id="序列化与反序列化">序列化与反序列化</h3>
<pre><code class="language-java">transient Object[] elementData;
</code></pre>
<p>在 ArrayList 源码看到的 <code>elementData</code> 带有关键字 <code>transient</code>，而通常 <code>transient</code> 关键字修饰了字段则表示该字段不会被序列化，但是 ArrayList 实现了序列化接口，并且提供的序列化方法 <code>writeObject</code> 与反序列化方法 <code>readObject</code> 的实现, 这是如何做到的呢？</p>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6khxdanx6j30t40kodj0.jpg" alt=""></figure>
<p>我们首先来看下 ArrayList 进行序列化的代码：</p>
<pre><code class="language-java">private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
    int expectedModCount = modCount;
    s.defaultWriteObject();

    s.writeInt(size);

    for (int i = 0; i &lt; size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
</code></pre>
<p>第4行代码首先将当前对象的非 <code>static</code> 修饰，非 <code>transient</code> 修饰的字段写出到流中；第6行将写出元素的个数作为容量。</p>
<p>接下来就是通过循环将包含的所有元素写出到流，在这一步可以看出 ArrayList 在自己实现的序列化方法中没有将无存储数据的内存空间进行序列化，节省了空间和时间。</p>
<p>同样地，在反序列化中根据读进来的流数据中获取 <code>size</code> 属性，然后进行数组的扩容，最后将流数据中读到的所有元素数据存放到持有的对象数组中。</p>
<pre><code class="language-java">private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    s.defaultReadObject();

    s.readInt(); // ignored

    if (size &gt; 0) {
        int capacity = calculateCapacity(elementData, size);
        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);
        ensureCapacityInternal(size);

        Object[] a = elementData;
        for (int i = 0; i &lt; size; i++) {
            a[i] = s.readObject();
        }
    }
}
</code></pre>
<h3 id="关于拷贝">关于拷贝</h3>
<p>针对列表元素的拷贝，ArrayList 提供自定义的 clone 实现如下：</p>
<pre><code class="language-java">public Object clone() {
  try {
    ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();
    v.elementData = Arrays.copyOf(elementData, size);
    v.modCount = 0;
    return v;
  } catch (CloneNotSupportedException e) {
    // this shouldn't happen, since we are Cloneable
    throw new InternalError(e);
  }
}
</code></pre>
<p>从上述代码可以清楚看出执行的 <code>copyOf</code> 操作是一次浅拷贝操作，原 ArrayList 对象的元素不会被拷贝一份存到新的 ArrayList 对象然后返回，它们各自的字段 <code>elementData</code> 里各位置存放的都是一样元素的引用，一旦哪个列表修改了数组中的某个元素，另一个列表也将受到影响。</p>
<h2 id="jdk-18-后的-arraylist">JDK 1.8 后的 ArrayList</h2>
<p>从源码角度分析完 ArrayList 的特性之后，我们再来看下 JDK 1.8 之后在 ArrayList 类上有什么新的变化。</p>
<h3 id="新增-removeif-方法">新增 removeIf 方法</h3>
<p><code>removeIf</code> 是 Collection 接口新增的接口方法，ArrayList 由于父类实现该接口，所以也有这个方法。<code>removeIf</code> 方法用于进行指定条件的从数组中删除元素。</p>
<pre><code class="language-java">public boolean removeIf(Predicate&lt;? super E&gt; filter){...}
</code></pre>
<p>传入一个代表条件的函数式接口参数 <code>Predicate</code>，也就是Lambda 表达式进行条件匹配，如果条件为 <code>true</code>， 则将该元素从数组中删除，例如下方代码示例：</p>
<pre><code class="language-java">List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
numbers.removeIf(i -&gt; i % 2 == 0);
System.out.println(numbers); // [1, 3, 5, 7, 9]
</code></pre>
<h3 id="新增-spliterator-方法">新增 spliterator 方法</h3>
<p>这个方法也是来自于 Collection 接口，ArrayList 对此方法进行了重写。该方法会返回 ListSpliterator 实例，该实例用于遍历和分离容器所存储的元素。</p>
<pre><code class="language-java">@Override
public Spliterator&lt;E&gt; spliterator() {
    return new ArrayListSpliterator&lt;&gt;(this, 0, -1, 0);
}
</code></pre>
<p>在 ArrayList 的实现中，该方法返回一个内部静态类对象 ArrayListSpliterator，通过它可以就可以集合元素进行操作。</p>
<p>它的主要操作方法有下面三种：</p>
<ul>
<li><code>tryAdvance</code> 迭代单个元素，类似于 <code>iterator.next()</code></li>
<li><code>forEachRemaining</code> 迭代剩余元素</li>
<li><code>trySplit</code> 将元素切分成两部分并行处理,但需要注意的 Spliterator 并不是线程安全的。</li>
</ul>
<p>虽然这个三个方法不常用，还是有必要了解，可以简单看下方法的使用方式</p>
<pre><code class="language-java">ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5,6));
Spliterator&lt;Integer&gt; numbers = numbers.spliterator();

numbers.tryAdvance( e -&gt; System.out.println( e ) ); // 1

numbers.forEachRemaining( e -&gt; System.out.println( e ) ); // 2 3 4 5 6

Spliterator&lt;Integer&gt; numbers2 = numbers.trySplit();

numbers.forEachRemaining( e -&gt; System.out.println( 3 ) );      //4 5 6
numbers2.forEachRemaining( e -&gt; System.out.println( 3 ) );      //1 2 3
</code></pre>
<h2 id="必会的使用姿势">必会的使用姿势</h2>
<p>接触了 ArrayList 源码和新API 之后，我们最后学习如何在平常开发中高效地使用 ArrayList。</p>
<h3 id="高效的初始化">高效的初始化</h3>
<p>ArrayList 实现了三个构造函数, 默认创建时会分配到空数组对象 <code>EMPTY_ELEMENTDATA</code>；第二个是传入一个集合类型数据进行初始化；第三个允许传入集合长度的初始化值，也就是数组长度。由于每次数组长度不够会导致扩容，重新申请更长的内存空间，并进行复制。而让我们初始化 ArrayList 指定数组初始大小，可以减少数组的扩容次数，提供性能。</p>
<pre><code class="language-java">public ArrayList(int initialCapacity) {
    if (initialCapacity &gt; 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                            initialCapacity);
    }
}

public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

public ArrayList(Collection&lt;? extends E&gt; c) {
    elementData = c.toArray();
    if ((size = elementData.length) != 0) {
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        this.elementData = EMPTY_ELEMENTDATA;
    }
}
</code></pre>
<h3 id="元素遍历">元素遍历</h3>
<p>JDK 1.8前，ArrayList 只支持3种遍历方式：迭代器遍历，普通 <code>for</code> 循环，<code>for-each</code> 增强，在 JDK1.8 引入了 Stream API 之后，同属于 Collection 集合的 ArrayList，可以使用 <code>stream.foreach()</code> 方法一个个地获取元素：</p>
<pre><code class="language-java">ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;(Arrays.asList( &quot;alex&quot;, &quot;brian&quot;, &quot;charles&quot;));
names.forEach(name -&gt; System.out.println(name)); // alex brian charles
</code></pre>
<h3 id="转换-array">转换  Array</h3>
<p>ArrayList 提供两个方法用于列表向数组的转换</p>
<pre><code class="language-java">public Object[] toArray();
public &lt;T&gt; T[] toArray(T[] a);
</code></pre>
<ol>
<li>第一个方法直接返回 Object 类型数组</li>
<li>在第二个方法中，返回数组的类型为所传入的指定数组的类型。 并且如果列表的长度符合传入的数组，将元素拷贝后数组后，则在其中返回数组。 否则，将根据传入数组的类型和列表的大小重新分配一个新数组，拷贝完成后再返回。</li>
</ol>
<p>从上述描述可以看出使用第二个方法更加合适，能保留原先类型：</p>
<pre><code class="language-java">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(4);
list.add(&quot;A&quot;);
list.add(&quot;B&quot;);
list.add(&quot;C&quot;);
list.add(&quot;D&quot;);

String[] array = list.toArray(new String[list.size()]);
System.out.println(Arrays.toString(array)); // [A, B, C, D]
</code></pre>
<h3 id="应对多线程">应对多线程</h3>
<p>在这里需要说明的是 ArrayList 本身是非线程安全的，如果需要使用线程安全的列表通常采用的方式是 <code>java.util.Collections#synchronizedList(java.util.List&lt;T&gt;)</code> 或者 使用 Vector 类代替。还有一种方式是使用并发容器类 CopyOnWriteArrayList 在多线程中使用，它底层通过创建原数组的副本来实现更新，添加等原本需同步的操作，不仅线程安全，减少了对线程的同步操作。</p>
<h3 id="应对头部结点的增删">应对头部结点的增删</h3>
<p>ArrayList是数组实现的，使用的是连续的内存空间，当有在数组头部将元素添加或者删除的时候，需要对头部以后的数据进行复制并重新排序，效率很低。针对有大量类似操作的场景，出于性能考虑，我们应该使用 LinkedList 代替。由于LinkedList 是基于链表实现，当需要操作的元素位置位于List 前半段时，就从头开始遍历，马上找到后将把元素在相应的位置进行插入或者删除操作。</p>
<h2 id="结语">结语</h2>
<p>到这里我们学习总结 ArrayList 的实现和常见使用，作为基础容器集合，越是多些了解，对我们日常使用越顺手。由于上文提到了另一个列表集合 LinkedList，它与 ArrayList 实现方式不同，使用场景也不同，将作为下一篇文章分析的集合登场，感兴趣的小伙伴欢迎关注我的微信公众号，期待更新。</p>
<figure data-type="image" tabindex="5"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6kircgfk8j30p00dwdhv.jpg" alt=""></figure>
<h2 id="参考">参考</h2>
<ul>
<li>https://www.cnblogs.com/skywang12345/p/3308556.html</li>
<li>https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html</li>
<li>https://yuqirong.me/2018/01/21/ArrayList%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</li>
<li>https://juejin.im/post/5a58aa62f265da3e4d72a51b</li>
<li>https://howtodoinjava.com/java-arraylist/</li>
<li>http://cmsblogs.com/?p=4727</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[掌握 Maven 私服]]></title>
        <id>https://wrcj12138aaa.github.io//post/20190825-掌握 Maven 私服</id>
        <link href="https://wrcj12138aaa.github.io//post/20190825-掌握 Maven 私服">
        </link>
        <updated>2019-08-25T13:30:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在 Java EE 开发中，我们使用 Maven 构建工具主要来管理项目的第三方库的依赖，以及公司内部其他项目服务的依赖，而 Maven 私服就是必不可少的一环，本文主要对 Maven 私服的三大方面进行介绍：</p>
<ul>
<li>什么是 Maven 私服</li>
<li>如何搭建 Maven 私服</li>
<li>如何使用 Maven 私服</li>
</ul>
<blockquote>
<p>本文面对的读者应有 Maven 使用经验，了解 Maven 的一些基本概念，如果不太熟悉可以参见文末的参考资料学习。</p>
</blockquote>
<h2 id="什么是-maven-私服">什么是 Maven 私服</h2>
<p>在介绍 Maven 私服之前，我们首先清楚下什么是 Maven 仓库。</p>
<p><strong>Maven 仓库：Maven 统一存储所有Maven项目依赖，插件，以及所上传项目的地方。</strong></p>
<p>并且 Maven 仓库还分成两类：本地仓库和远程仓库。</p>
<ul>
<li>本地仓库，就是我们本地电脑安装Maven后，在 配置文件 setting.xml 里 <code>localRepository</code> 所需要指定目录的那个文件夹。</li>
<li>远程仓库，就是在外部网络里（包括局域网）指定 URL 的专门存放 Java 库，Maven插件等的服务器，，例如中央仓库，就是一个典型的远程仓库，它包含了世界上绝大多数开源的 Java 库，类似的还有许多其他的公开库</li>
</ul>
<p>而本文提到的私服，就是另一种特殊的远程仓库，它通常架设在局域网内的一台服务器上，用于代理所有外部的远程仓库，并且能接受内部项目的上传和获取。</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bylbdlpij315q0myq4t.jpg" alt=""></figure>
<p>而这些仓库又有是什么用呢？当 Maven 项目需要依赖一些其他项目的 Java 库时，Maven 首先会在本地仓库查找，如果存在对应的库，就直接使用；如果本地仓库不存在，Maven 就会去远程仓库查找，找到对应的 Java 库后下载到本地仓库再使用，以便于下次需要该Java库时，直接使用缓存在本地仓库的依赖库即可，省去了重复通过网络查找并下载的时间，对于 Maven 插件也是同样的过程。</p>
<p>通常情况下，中央仓库是Maven 默认的远程仓库，而当引入了私服后，本地仓库查找结束未找到所需要的依赖库时，就先从私服仓库开始查找，仍未找到的话，最后再去中央仓库查找，具体过程可以参考下图：</p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bzczhk5zj31bq0kgdia.jpg" alt="image-20190825155914631"></figure>
<p>在这里我们再看下私服的作用有哪些：</p>
<ul>
<li>内网访问，节省外网带宽。</li>
<li>一次外网下载，内网所有用户就可以只下载私服缓存，加速 Maven 项目构建。</li>
<li>允许上传和下载私有库，并且不被外部访问，更加安全。</li>
<li>减少外部网络因素，提供项目构建的稳定性。</li>
<li>方便内部项目服务的依赖引用，而不需要其他项目的完整源代码。</li>
</ul>
<p>这里对最后一小点的作用添加下具体描述：当我们有独立的两个Maven 项目，比如订单服务项目和会员服务项目，其中订单服务项目需要会员服务，依赖会员服务的 API 包，通过私服可以将编译后的会员服务的 API 包上传，然后订单服务程序直接下载引用私服上的会员服务 API 包即可，这样就不需要导入会员服务项目代码，也不用关心会员服务具体实现了，起到了内部服务项目轻度引用的作用，描述可参见下图。</p>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c0ax37pcj30pw0jc0ud.jpg" alt=""></figure>
<h2 id="搭建-maven-私服">搭建 Maven 私服</h2>
<p>了解 Maven 私服之后，我们进一步学习。我们首先来搭建一个 Maven 私服。在这里我们使用最流行的开源 Maven 仓库管理软件 -  Nexus，来快速搭建 Maven 私服，传统的搭建方式为在 Nexus 官网上下载开源版的 Nexus OSS 进行安装：https://www.sonatype.com/nexus-repository-oss。而本文将采用 Docker 方式安装 Nexus，不仅快速简单，而占用更少的机器资源。</p>
<blockquote>
<p>如果对 Docker 不熟悉的同学，可以参见 <a href="https://juejin.im/post/5d4522c1f265da03e05af5f5?utm_source=gold_browser_extension%23heading-34">10分钟快速掌握Docker必备基础知识</a> 学习了解下，简单使用 Docker 也是十分容易的。</p>
</blockquote>
<h3 id="下载-nexus-镜像">下载 Nexus 镜像</h3>
<p>在终端控制台上使用 Docker 指令下载 Nexus 官方提供的Docker 镜像：<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6cahq8wslj311s03wt8p.jpg" alt=""></p>
<p>看到下图结果时，就表示镜像下载完成，可以通过 <code>docker images</code> 查看。</p>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c0zl1pbbj310q0aqgn6.jpg" alt="image-20190825165531217"></figure>
<h3 id="启动-nexus-容器">启动 Nexus 容器</h3>
<p>使用下方指令启动 Nexus 容器：<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6cahdg9jtj31kw05awf6.jpg" alt=""></p>
<p>在这里对输入的 Docker 指令的参数进行简单的说明：</p>
<ul>
<li>
<p><code>-d</code> 表示让容器后台运行。</p>
</li>
<li>
<p><code>-p 8081:8081</code> 表示了容器启动时开放内部端口 8081（后者的8081） 映射主机端口的 8081 ，即通过 <code>localhost:8081</code>  可以访问到 Nexus 容器所提供的服务。</p>
</li>
<li>
<p><code>-v /Users/One/Desktop/Nexus/nexus-data:/nexus-data</code> 表示将容器内部 <code>/var/nexus-data</code> 挂载到当前主机的指定目录，需要注意的是，<code>-v</code> 指定的外部路径必须为全路径。</p>
</li>
<li>
<p><code>--restart=always</code> 比较简单，表示当 docker 服务启动时，该容器也跟着启动。</p>
</li>
</ul>
<p>执行上述指令后，稍等片刻，访问 <code>http://localhost:8081/</code> ，看到对应的 Nexus 后台就表示私服安装完成了，是不是很简单呢。<br>
<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c1hyrynij32fu0p2tbx.jpg" alt=""></p>
<blockquote>
<p>容器启动过程中，由于机器配置的不同，可能会出现启动慢的情况，只需耐心等待即可。</p>
</blockquote>
<p>启动完成后，我们可以在所挂载的本机目录下查看 Nexus 容器运行产生的文件。</p>
<figure data-type="image" tabindex="5"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6c9t93pizj30xy07gq3i.jpg" alt=""></figure>
<h2 id="配置-maven-私服">配置 Maven 私服</h2>
<p>私服安装之后，我们首先进行登录操作，点击页面左上角的 Sign In 按钮，就会出现和下图一样的提示：</p>
<figure data-type="image" tabindex="6"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c23iu75mj31hu0u0jub.jpg" alt=""></figure>
<p>说明了 Nexus 默认登录账号为 admin，并且密码位于文件 <code>/nexus-data/admin.password</code> 下，我们只需在本地配置的挂载目录下查看该文件即可。</p>
<figure data-type="image" tabindex="7"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c26l36ejj30zw04sgm9.jpg" alt=""></figure>
<p>输入默认的账号密码之后成功登录之后，Nexus 就会强制要求修改 admin 的密码,并且设置基本访问权限，完成之后就正式进入了 Nexus 私服后台。</p>
<figure data-type="image" tabindex="8"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c2gijrt2j32fk0icdj4.jpg" alt=""></figure>
<p>这里简单对界面元素进行介绍：</p>
<ol>
<li>默认的浏览界面，可以搜索查看仓库的组件，以及进行上传操作。</li>
<li>用于管理私服程序的配置。</li>
<li>账户信息查看，允许修改密码。</li>
</ol>
<p>进入私服程序的配置界面，我们需要对默认配置进行几点调整。</p>
<h3 id="中央仓库的代理路径设置">中央仓库的代理路径设置</h3>
<p>将私服配置里中央仓库的代理仓库路径更新为<a href="https://maven.aliyun.com/mvn/view">阿里云仓库</a>提供的代理地址：https://maven.aliyun.com/repository/central  这样一来可以更快速地访问在中央仓库上所需要的依赖和插件。</p>
<figure data-type="image" tabindex="9"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c2pxiw3jj31ac0u0k12.jpg" alt=""></figure>
<h3 id="新建自定义的仓库">新建自定义的仓库</h3>
<p>点击<code>Create repository</code>,然后选择类型为 <code>maven2(hosted)</code></p>
<figure data-type="image" tabindex="10"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c33pl9hzj317m0rmtbj.jpg" alt=""></figure>
<p>然后输入仓库名称 private-release，并在 Version policy 一栏中选择 Release，表示这个仓库的存储依赖为正式发布的组件，然后在 Deployment policy 一栏中选择 Allow redeploy，允许部署和更新私服上的组件。</p>
<figure data-type="image" tabindex="11"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c359czrej30zq0u0adq.jpg" alt=""></figure>
<p>最后点击蓝色按钮-<code>Create repository</code> 之后，就可以在仓库列表看到自定义的仓库了，有了 release 仓库，我们再按照同样方式操作添加一个 snapshot 仓库，只需在  Version policy  一栏调整为 Snapshot 即可。</p>
<figure data-type="image" tabindex="12"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c3cg9wuhj329k0pkn51.jpg" alt=""></figure>
<h3 id="添加角色">添加角色</h3>
<p>Nexus 默认只有两种角色：<code>nx-anonymous</code> 和 <code>nx-admin</code>，前者只有浏览的权限，后者为管理员权限，一般情况下，我们还需要正对开发人员创建个角色。点击 <code>Create Role</code>，添加一个 Role ID 为 <code>developer</code> 的自定义角色,  并且只添加自定义仓库的使用权限，删除操作除外。</p>
<figure data-type="image" tabindex="13"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c7nbl8q6j312d0u07h1.jpg" alt=""></figure>
<p>保存之后，新增的角色就展示在列表中，有了角色，就可以关联用户，进行权限分配了。</p>
<figure data-type="image" tabindex="14"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c4msmur8j31w80l6gpf.jpg" alt="image-20190825190139940"></figure>
<h3 id="添加用户">添加用户</h3>
<p>跟权限类似，默认的用户只有两种：<code>admin</code> 和 anonymous，我们同样需要创建属于开发者的用户对象。点击 <code>Create local user</code>，填入用户名，密码等必填信息之后，关联我们先前的创建的角色，并保存即可。</p>
<figure data-type="image" tabindex="15"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c4r9flvqj316e0u0ahw.jpg" alt=""></figure>
<p>用户创建完成之后，我们就可以用新的用户登录私服，查看对应权限的内容了，例如我们用新建的用户登录，所能操作的只有查看和搜索自定义的私服仓库。</p>
<figure data-type="image" tabindex="16"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c4txtbt8j32fi0gediz.jpg" alt=""></figure>
<p>这样一来我们就创建好了自己的私服仓库，配置完成之后，开发者就可以在 Maven 项目开发中使用了。</p>
<h2 id="使用-maven-私服">使用 Maven 私服</h2>
<p>有了私服和用于开发的账号，我们就需要在本地 Maven 配置文件 setting.xml 进行关联。</p>
<p>设置 server 账户信息：<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6caenutlsj311s0j640d.jpg" alt=""></p>
<p>设置私服仓库地址：（这里的地址，可以通过 Nexus 后台上仓库页面的 <code>cpoy</code> 按钮自动复制得到）<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6caek5x1mj313c0ri777.jpg" alt=""></p>
<h3 id="maven-项目部署到私服">Maven 项目部署到私服</h3>
<p>配置完成后，我们可以创建一个Maven工程，尝试下打包到 Maven 私服。利用 IDE 快速生成 Maven 项目，在 POM 文件添加 <code>distributionManagement</code> 节点，并且指定对应的私服仓库 id 和地址，如下：<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6cafcau8cj313e0u0jv6.jpg" alt=""></p>
<p>最后只要执行部署命令  <code>mvn clean deploy</code> 或者利用 IDE 的 部署插件即可，当控制台出现 <code>BUILD SUCCESS</code> ，如下图类似时则说明部署完成。</p>
<figure data-type="image" tabindex="17"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6c7z3lna1j31fl0u0156.jpg" alt=""></figure>
<p>从日志上可以看出，我们的项目上传都了 private- snapshot 仓库下，此时我们可以在私服网站上的  private- snapshot 仓库查看到上传的 jar。</p>
<figure data-type="image" tabindex="18"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6c83m7uozj316e0jo402.jpg" alt=""></figure>
<blockquote>
<p>如果部署过程中出现如下提示：带有 <code>Access denied to</code> 则说明在 setting.xml 配置的用户权限不足，无法将 jar 部署到对应私服仓库上去。</p>
<figure data-type="image" tabindex="19"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6c7kijqodj31ie08imz4.jpg" alt=""></figure>
</blockquote>
<p>需要注意的是，对于一个Maven项目而言，如果项目的版本号中有 “SNAPSHOT” 字样，则表示当前处于开发版本，Maven 会将发布到 <code>snapshotRepository</code> 节点对应地址上去。否则，Maven则认为这是一个发布版本，将程序发布到 <code>repository</code> 节点对应的地址上。由于示例项目的版本为 <code>1.0.0-SNAPSHOT</code> ，所以最终项目上传到了 <code>private-snapshot</code> 这个 Snapshot 类型的仓库下。</p>
<p>接下来如果其他项目要依赖这个 jar 时，只需要在其 POM 文件引入对应的坐标即可。</p>
<figure data-type="image" tabindex="20"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6cag20juzj311s09gt9j.jpg" alt=""></figure>
<h3 id="将第三方-jar-包部署到-maven-私服">将第三方 jar 包部署到 Maven 私服</h3>
<p>这里说到了第三方 jar 包，不是平常所提到的开源库，更多的是来自其他第三方系统的 jar 包，由于项目需要，使用项目导入的方式来很不方便，更好的处理方式就是将第三方系统的 jar 包手动上传到 Maven 私服上，需要使用的项目直接从私服仓库中拉取即可。</p>
<p>这种方式实现起来也比较方便，分为两种：可视化界面操作和命令行操作。</p>
<p>可视化界面操作：就是在 Nexus 后台上进去，执行上传操作必须要对于的上传权限才可以，一般都是管理员账号进行操作，选择仓库后进去上传页面，指定本地需要上传的项目，自定义完坐标信息保存即可。</p>
<figure data-type="image" tabindex="21"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6c99d2l6nj31dx0u0wlh.jpg" alt=""></figure>
<p>命令行方式：直接在终端输入下面指令即可：<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6cagfocvtj31kw05a3zd.jpg" alt=""></p>
<ul>
<li>-DgroupId 和 -DartifactId 构成了该jar包在 pom.xml 的坐标， 即对应依赖的 <code>groupId</code> 和 <code>artifactId</code></li>
<li>-<code>Dfile</code> 表示需要上传的jar包的绝对路径</li>
<li>-Durl 为私服仓库的url精确地址</li>
<li>-DrepositoryId 为私服仓库定义的id</li>
<li>-Dversion 指定了版本号</li>
<li>-Dpackaging 指定了打包方式</li>
</ul>
<p>当控制台日志出现 <code>BUILD SUCCESS</code> 信息时则表示打包成功，如果出现打包失败，很有可能是 Maven 配置文件里 <code>server</code> 元素下的用户权限不足导致，需要 Nexus 后台对用户角色进行上传权限的分配。</p>
<h2 id="结语">结语</h2>
<p>在 Java 企业级项目开发中，建立并维护私服是使用 Maven 必不可少的一步，本文从 Maven 的简单介绍，到快速搭建和使用来进一步掌握 Maven 私服，为后续的企业微服务架构做好铺垫。</p>
<figure data-type="image" tabindex="22"><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6ca7tzjs7j30p00dw404.jpg" alt=""></figure>
<h2 id="推荐阅读">推荐阅读</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/TfA8rSwYNpW3YV_N8oLJnw">一文掌握 Spring Boot Profiles</a></li>
<li><a href="https://mp.weixin.qq.com/s/-t2hrrVMBpPmVEzDcC8J5w">如何优雅关闭 Spring Boot 应用</a></li>
<li><a href="https://mp.weixin.qq.com/s/uWRnRhH4et-XSD101Xh6LQ">需要接口管理的你了解一下？</a></li>
<li><a href="https://mp.weixin.qq.com/s/2qkNz4VPgnixXjaVYUkvvQ">Java 之 Lombok 必知必会</a></li>
<li><a href="https://mp.weixin.qq.com/s/vS36glyNoD26GL6cbNs5Qw">Java 微服务新生代之 Nacos</a></li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p>Maven入门，读完这篇就够了：https://juejin.im/post/5a4a5e2bf265da4322418d7f#heading-2</p>
</li>
<li>
<p>Maven 实战：https://book.douban.com/subject/5345682/</p>
</li>
<li>
<p>私服 maven 仓库命令上传 jar 包： https://www.jianshu.com/p/ccd7b643624c</p>
</li>
<li>
<p>What is a Maven Repository：https://medium.com/@chris.shellenbarger/what-is-a-maven-repository-6fa22991fad9</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[聊一聊 Java 字符串的不可变]]></title>
        <id>https://wrcj12138aaa.github.io//post/20190817-聊一聊 Java 字符串的不可变</id>
        <link href="https://wrcj12138aaa.github.io//post/20190817-聊一聊 Java 字符串的不可变">
        </link>
        <updated>2019-08-17T13:13:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在 Java 开发中 String （字符串）对象是我们使用最频繁的对象，也是很重要的对象。正是使用得如此频繁，String 在实现层面上不断进行优化，从 Java6 到 Java7，再到 Java9 的新实现 ，都是为了提升 String 对象的性能，而其中不变的是 String 所生俱来的特性：不可变。本文主要聊一聊 String 的不可变，以及为什么存在的。</p>
<h2 id="什么是-string-的不可变">什么是 String 的不可变</h2>
<p>首先我们先来看下什么是不可变对象：<strong>一旦对象被创建并初始化后，内部的状态数据就会保持不变</strong>。查看 JDK 源码中的 String 类，可以看到类本身被 final 修饰，并且内部的大部分属性都是 final 修饰的，除了字段 hash 是通过字符串内容计算并缓存起来的。这样的行为让 String 类无法被扩展，内部属性也无法被修改。</p>
<p>接着我们再来用画图的形式来说明下 String 的不可变性。</p>
<p>通常我们初始化字符串都是以下形式：<img src="http://ww4.sinaimg.cn/large/006tNc79gy1g6449rba87j311s03wwei.jpg" alt=""></p>
<p>String 类型的引用变量 <code>a</code> 保留了一个字符串对象 <code>string</code> 的引用，就如同下图所示，箭头则表示了变量 <code>a</code> 与真正 String 对象的引用关系。</p>
<figure data-type="image" tabindex="1"><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g63x04p4ofj30vi0g20uc.jpg" alt=""></figure>
<figure data-type="image" tabindex="2"><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g644ac50eyj311s03wjrc.jpg" alt=""></figure>
<p>再通过上述代码，我们将变量 <code>a</code> 赋值给变量 <code>b</code> ，变量 <code>b</code> 也存储了字符串对象 <code>string</code>的引用，它们指向的是同一个对象。</p>
<figure data-type="image" tabindex="3"><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g63x8m4y36j30we0gsjt9.jpg" alt=""></figure>
<p>当我们尝试对变量 <code>a</code> 重新赋值，看下对变量 <code>b</code> 会不会有影响呢</p>
<figure data-type="image" tabindex="4"><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g647oodezyj311s05aq37.jpg" alt=""></figure>
<p>想必小伙伴一看就知道，打印的结果肯定是 <code>string2,string</code>，同样用画图的方式展示这两个变量与字符串对象的引用关系。</p>
<figure data-type="image" tabindex="5"><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g63xolkt6rj30w40hgdhz.jpg" alt=""></figure>
<p>将变量 <code>a</code> 重新赋值后，保存了新的引用，而不是直接在原有的字符串对象上进行数据改变，同时变量 <code>b</code> 仍然存的是对象 <code>string</code> 的引用，变量 <code>a</code> 和 <code>b</code> 两者相互独立，不影响，这也正是说明了 String 对象的不可变。</p>
<p>在这里初认 Java 的小伙伴还可能会有些困惑：对一个String对象 <code>a</code> 赋值 <code>string</code>，然后又让 <code>a</code> 值为 <code>string2</code>，这个时候a的值变成 了<code>string2</code>, <code>a</code> 的值改变了，为什么还说 String 对象不可变呢。</p>
<p>其实问题也很简单，这里的 <code>a</code> 只是存储 String 对象的引用，并不是对象本身，<code>a</code> 存储的是指向对象所在内存的地址引用罢了，当第二次赋值时，<code>a</code> 引用指向了对象 <code>string2</code>的内存地址，而对象 <code>string2</code> 是重新创建的，之前的 <code>string</code> 对象仍在内存中，并且由变量 <code>b</code> 引用着。</p>
<p>除此之外，String 类的返回 String 对象的方法不会改变自身，都是返回一个新的 String 对象来实现，比如 <code>concat</code>，<code>replace</code>，<code>substring</code> 等等。</p>
<figure data-type="image" tabindex="6"><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g644ankj6uj311s0gegno.jpg" alt=""></figure>
<h2 id="为什么-string-需要不可变">为什么 String 需要不可变</h2>
<p>聊完什么是 String 的不可变后，接下来我们再说说 String 为什么需要不可变呢，又有什么好处呢？</p>
<h3 id="字符串常量池的实现">字符串常量池的实现</h3>
<p>在Java中，我们通常有两种方式创建字符串对象，一种是通过字符串字面量方式创建，就如上文的代码，另外一种就是通过 new 方式去创建，如 <code>String c = new String(&quot;string 3&quot;);</code> 而两者区别就在于通过字符串字面量的方式创建时，JVM 会现在字符串池中检查字符串内容是否已经存在，如果存在就会直接返回对应的引用，而不是再次分配内存进行创建，如果不存在就会分配在内存中创建的同时将字符串数据缓存在字符串池中，便于重用。正是是由于字符串的不可变，同样的字符串内容可以让 JVM 可以减少额外的内存分配操作，直接使用在字符串池中字符串对象即可，对性能提升和内存节省都大有好处。</p>
<figure data-type="image" tabindex="7"><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g63zckg8slj30pb0fndgr.jpg" alt=""></figure>
<p>关于字符串池，这里稍微简单介绍一下：**Java 的字符串池属于 JVM 专门给指定的特殊内存区域，用来存储字符串字面量。**在 Java 7 之前，分配于 JVM 的方法区内，属于常量池的一部分；而 Java7 之后字符串池被移至堆内存进行管理，这样的好处就是允许被 JVM 进行垃圾回收操作，将未被引用的字符串所占内存即使回收，以此节省内存。</p>
<h3 id="hashcode-缓存">Hashcode 缓存</h3>
<p>字符串作为基础的数据结构，大量地应用在一些集合容器之中，尤其是一些散列集合，在散列集合中，存放元素都要根据对象的 <code>hashCode()</code> 方法来确定元素的位置。由于字符串  <code>hashcode</code>  属性不会变更，保证了唯一性，使得类似 HashMap，HashSet 等容器才能实现相应的缓存功能。由于 String 的不可变，避免重复计算 <code>hashcode</code>，只有使用缓存的 <code>hashcode</code> 即可，这样一来大大提高了在散列集合中使用 String 对象的性能。</p>
<h3 id="线程安全">线程安全</h3>
<p>在多线程中，只有不变的对象和值是线程安全的，可以在多个线程中共享数据。由于 String 天然的不可变，当一个线程”修改“了字符串的值，只会产生一个新的字符串对象，不会对其他线程的访问产生副作用，访问的都是同样的字符串数据，不需要任何同步操作。</p>
<h3 id="安全性">安全性</h3>
<p>由于字符串无论在任何 Java 系统中都广泛使用，会用来存储敏感信息，如账号，密码，网络路径，文件处理等场景里，保证字符串 String 类的安全性就尤为重要了，如果字符串是可变的，容易被篡改，那我们就无法保证使用字符串进行操作时，它是安全的，很有可能出现 SQL 注入，访问危险文件等操作。</p>
<h2 id="结语">结语</h2>
<p>通过本文，我们介绍 String 是不可变的，可以将它们的引用可以被当作一个普通的变量来使用，无论是在方法间，还是线程间传递它们，都不用担心它指向的实际 String 对象发生改变，并且不可变的特性也在语言层面和程序层面上带了许多好处，在平常编程实践中我们也应该多学习效仿，用  James Gosling，Java之父的话说就是”我会尽可能地使用不可变对象“。</p>
<figure data-type="image" tabindex="8"><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g645sxo8k0j30p00dw7bh.jpg" alt=""></figure>
<h2 id="推荐阅读">推荐阅读</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/TfA8rSwYNpW3YV_N8oLJnw">一文掌握 Spring Boot Profiles</a></li>
<li><a href="https://mp.weixin.qq.com/s/-t2hrrVMBpPmVEzDcC8J5w">如何优雅关闭 Spring Boot 应用</a></li>
<li><a href="https://mp.weixin.qq.com/s/uWRnRhH4et-XSD101Xh6LQ">需要接口管理的你了解一下？</a></li>
<li><a href="https://mp.weixin.qq.com/s/2qkNz4VPgnixXjaVYUkvvQ">Java 之 Lombok 必知必会</a></li>
<li><a href="https://mp.weixin.qq.com/s/vS36glyNoD26GL6cbNs5Qw">Java 微服务新生代之 Nacos</a></li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p>Diagram to show Java String’s Immutability：https://www.programcreek.com/2009/02/diagram-to-show-java-strings-immutability/</p>
</li>
<li>
<p>Why String is Immutable in Java：https://www.baeldung.com/java-string-immutable</p>
</li>
<li>
<p>Guide to Java String Pool：https://www.baeldung.com/java-string-pool</p>
</li>
<li>
<p>Why String is immutable in Java： https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/</p>
</li>
<li>
<p>The Structure of the Java Virtual Machine：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot Profiles 源码解析]]></title>
        <id>https://wrcj12138aaa.github.io//post/20190813-SpringBootProfiles源码解析</id>
        <link href="https://wrcj12138aaa.github.io//post/20190813-SpringBootProfiles源码解析">
        </link>
        <updated>2019-08-13T13:13:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>上文<a href="https://mp.weixin.qq.com/s/TfA8rSwYNpW3YV_N8oLJnw">《一文掌握 Spring Boot Profiles》</a> 是对 Spring Boot Profiles 的介绍和使用，因此本文将从源码角度探究 Spring Boot Profiles，让我们看下 Spring Boot 底层是如何应用 Profiles 进行环境配置的隔离与生效的。</p>
<h2 id="正文">正文</h2>
<p>首先，我们先来看下一个简单的 Spring Boot 示例程序，</p>
<pre><code class="language-java">@SpringBootApplication
@Slf4j
public class SimapleSpringApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(SimapleSpringApplication.class, args);
        User user = context.getBean(User.class);
        log.warn(&quot;User Bean: {}&quot;, user);
    }
}
</code></pre>
<p>在主程序方法中，打印容器中获取到 User 对象，它只有一个 <code>name</code> 属性。</p>
<pre><code class="language-java">@Data
@Component
public class User {
    @Value(&quot;${user.username}&quot;)
    private String name;
}
</code></pre>
<p>这里 <code>name</code> 属性引用了外部配置  <code>user.username</code> 的值，它是从配置文件中读取，这里我定义两个配置文件设置该属性，<code>application.properties</code> 和 <code>application-prod.properties</code>。</p>
<pre><code class="language-properties"># application.properties 
user.username=one

# application-prod.properties
user.username=one-prod
</code></pre>
<p>有了配置文件之后，启动 <code>SimapleSpringApplication</code> 程序，我们首先可以看到日志输入：<code>User Bean: User(name=one)</code>，由此可以看出程序读取了 <code>application.properties</code>  的 <code>user.username</code> 配置。现在我们在 <code>application.properties</code> 中加入一行：</p>
<pre><code class="language-properties">spring.profiles.active=prod
</code></pre>
<p>再次重启启动程序，可以看到控制台如下日志：</p>
<pre><code class="language-bash">2019-08-11 18:16:22.787  INFO 4849 --- [           main] c.o.l.s.demo.SimapleSpringApplication    : Starting SimapleSpringApplication on 192.168.0.119 with PID 4849 (started by one in /Users/One/Nutstore Files/One/OpenSource/springboot-profiles-sources)
2019-08-11 18:16:22.789  INFO 4849 --- [           main] c.o.l.s.demo.SimapleSpringApplication    : The following profiles are active: prod
2019-08-11 18:16:23.143  INFO 4849 --- [           main] c.o.l.s.demo.SimapleSpringApplication    : Started SimapleSpringApplication in 0.575 seconds (JVM running for 0.957)
2019-08-11 18:16:23.145  WARN 4849 --- [           main] c.o.l.s.demo.SimapleSpringApplication    : User Bean: User(name=one-prod)
</code></pre>
<p>此时 User 对象的name属性变成了 <code>application-prod.properties</code> 中定义的值，并且日志提示  <code>The following profiles are active: prod</code> 表明了名称为 <code>prod</code>  的Profile 在程序中激活。接下来我们就从这个日志入手，探究下这一切是如何发生的。</p>
<p>首先，根据 IDE 的全局查找功能，直接搜索 <code>The following profiles are active:</code>  这些词出现的位置，进行定位，可以找到这个日志出现于 <code>SpringApplication#logStartupProfileInfo</code> 方法之中。</p>
<figure data-type="image" tabindex="1"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5vwt5ae3qj31pm0u014n.jpg" alt=""></figure>
<pre><code class="language-java">	protected void logStartupProfileInfo(ConfigurableApplicationContext context) {
		Log log = getApplicationLog();
		if (log.isInfoEnabled()) {
			String[] activeProfiles = context.getEnvironment().getActiveProfiles();
			if (ObjectUtils.isEmpty(activeProfiles)) {
				String[] defaultProfiles = context.getEnvironment().getDefaultProfiles();
				log.info(&quot;No active profile set, falling back to default profiles: &quot;
						+ StringUtils.arrayToCommaDelimitedString(defaultProfiles));
			}
			else {
				log.info(&quot;The following profiles are active: &quot;
						+ StringUtils.arrayToCommaDelimitedString(activeProfiles));
			}
		}
	}
</code></pre>
<p>从日志方法可以看出打印的 <code>activeProfiles</code> 来自上下文关联的 <code>environment</code> 对象，再进一步查看 <code>logStartupProfileInfo</code> 的调用位置，可以在 <code>SpringApplication#prepareContext</code> 方法之中找到，这个方法从命名上就可以看出是主要负责 Spring Boot 运行前容器上下文的预备工作，</p>
<pre><code class="language-java">	private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,
			SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {
		context.setEnvironment(environment);
		postProcessApplicationContext(context);
		applyInitializers(context);
		listeners.contextPrepared(context);
		if (this.logStartupInfo) {
			logStartupInfo(context.getParent() == null);
			logStartupProfileInfo(context);
		}
		// Add boot specific singleton beans
    // ...
		// Load the sources
    // ...
		listeners.contextLoaded(context);
	}
</code></pre>
<p>我们重新运行程序，通过断点方式拦截 <code>SpringApplication#prepareContext</code> 方法的指向， 获取 <code>environment</code>对象真实的类型为 StandardEnvironment，是 Environment 接口非Web环境的标准实现，存储着一些应用配置和 Profiles 信息，如果在Web环境下，context 关联的就是 StandardServletEnvironment 类型的对象。</p>
<figure data-type="image" tabindex="2"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5w37sz5y7j31d80u0k2q.jpg" alt="image-20190811220336681"></figure>
<p>知道了日志打印来自 StandardEnvironment 对象的 activeProfiles 属性之后，就需要来看它是在什么时间被赋值的了。继续从调用链的上一级查找，就到了 <code>SpringApplication#run(java.lang.String...)</code>，这也是整个程序启动的主要方法。</p>
<figure data-type="image" tabindex="3"><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5w3cbdypdj320u0ryk1y.jpg" alt="image-20190811220752235"></figure>
<p>从图中可以看出第一次获取到的 environment 对象来自 <code>SpringApplication#prepareEnvironment</code> 内部生成， <code>prepareEnvironment</code> 方法内部首先通过 <code>getOrCreateEnvironment</code> 获取一个基础的 <code>ConfigurableEnvironment</code> 实例，然后对该实例对象初始化配置返回。</p>
<pre><code class="language-java">	private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,
			ApplicationArguments applicationArguments) {
		// Create and configure the environment
		ConfigurableEnvironment environment = getOrCreateEnvironment();
		configureEnvironment(environment, applicationArguments.getSourceArgs());
		listeners.environmentPrepared(environment);
		bindToSpringApplication(environment);
		if (!this.isCustomEnvironment) {
			environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,
					deduceEnvironmentClass());
		}
		ConfigurationPropertySources.attach(environment);
		return environment;
	}
</code></pre>
<p>正在创建 <code>environment</code> 对象来自 <code>SpringApplication#getOrCreateEnvironment</code>，看它的实现就可以验证我们之前提到  <code>environment</code> 对象类型为 StandardEnvironment。</p>
<pre><code class="language-java">	private ConfigurableEnvironment getOrCreateEnvironment() {
		if (this.environment != null) {
			return this.environment;
		}
		switch (this.webApplicationType) {
		case SERVLET:
			return new StandardServletEnvironment();
		case REACTIVE:
			return new StandardReactiveWebEnvironment();
		default:
			return new StandardEnvironment();
		}
	}
</code></pre>
<p>了解完  <code>environment</code> 的创建，接下来就关注 <code>environment</code> 的初始化了，这里我们需要关注 <code>listeners.environmentPrepared(environment)</code> 这行代码，这里的 listeners 为 SpringApplicationRunListeners 实例，是监听器 SpringApplicationRunListener 的集合对象， <code>SpringApplicationRunListener#environmentPrepared</code> 方法中就是对每个 SpringApplicationRunListener 对象遍历指向类似的 <code>environmentPrepared</code> 方法，当前集合中只有一个 EventPublishingRunListener 实例，查看其 <code>environmentPrepared</code> 方法就可以看到它主要就是用于发布包含 <code>environment</code> 实例的 <code>ApplicationEnvironmentPreparedEvent</code> 事件，让其他所有监听该事件的监听器进行  <code>environment</code> 实例的配置。</p>
<figure data-type="image" tabindex="4"><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5w3ri69quj31ra08gmz9.jpg" alt="image-20190811222233932"></figure>
<p>事件对象 ApplicationEnvironmentPreparedEvent  还有一个 getEnvironment 方法获取所传递的 environment实例，我们可以通过看这个方法被使用的地方，获取有哪些类在配置 environment 对象。</p>
<figure data-type="image" tabindex="5"><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5w3wvkb58j31sq0e6q8o.jpg" alt="image-20190811222743323"></figure>
<p>经过多次的查看，从上图可以定位到 ConfigFileApplicationListener 类内的方法对 environment 对象进行扩展，从命名可以看出这个监听器跟配置文件相关，比如它的一些常量属性：<code>CONFIG_NAME_PROPERTY</code>，<code>CONFIG_LOCATION_PROPERTY</code>等。从类的注释可以看出，Spring Boot 程序启动所加载的 <code>application.properties</code> 或 <code>application.yml</code> 默认从四个路径下加载，我们最常用的就是最后一种，它也可以告诉我们还可以把配置文件放在哪，如何自定义加载配置文件的路径。</p>
<ul>
<li>file:./config/:</li>
<li>file:./</li>
<li>classpath:config/</li>
<li>classpath:</li>
</ul>
<pre><code class="language-java">/**
 * {@link EnvironmentPostProcessor} that configures the context environment by loading
 * properties from well known file locations. By default properties will be loaded from
 * 'application.properties' and/or 'application.yml' files in the following locations:
 * &lt;ul&gt;
 * &lt;li&gt;file:./config/:&lt;/li&gt;
 * &lt;li&gt;file:./&lt;/li&gt;
 * &lt;li&gt;classpath:config/&lt;/li&gt;
 * &lt;li&gt;classpath:&lt;/li&gt;
 * &lt;/ul&gt;
 * The list is ordered by precedence (properties defined in locations higher in the list
 * override those defined in lower locations).
 * &lt;p&gt;
 * Alternative search locations and names can be specified using
 * {@link #setSearchLocations(String)} and {@link #setSearchNames(String)}.
 * &lt;p&gt;
 * Additional files will also be loaded based on active profiles. For example if a 'web'
 * profile is active 'application-web.properties' and 'application-web.yml' will be
 * considered.
 * &lt;p&gt;
 * The 'spring.config.name' property can be used to specify an alternative name to load
 * and the 'spring.config.location' property can be used to specify alternative search
 * locations or specific files.
 * &lt;p&gt;
 */
public class ConfigFileApplicationListener implements EnvironmentPostProcessor, SmartApplicationListener, Ordered {
  //...
}
</code></pre>
<p>将程序断点设置于 <code>ConfigFileApplicationListener#onApplicationEvent</code> 方法之内，重新运行程序就看到程序此时运行到了 <code>ConfigFileApplicationListener</code> 类之中，内部经过多个方法调用从  <code>onApplicationEvent</code> 来到了 <code>addPropertySources</code> 方法,这个方法就是配置文件的属性源加载到 environment 环境去的。</p>
<figure data-type="image" tabindex="6"><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5w4iv19wqj31kw0no0yr.jpg" alt="image-20190811224851204"></figure>
<p>这里的 <code>Loader</code> 是 <code>ConfigFileApplicationListener</code>类内部私有类，用于协调属性源和配置 Profiles，我们再进一步跟踪到它的 load 方法。</p>
<pre><code class="language-java">		public void load() {
			this.profiles = new LinkedList&lt;&gt;();
			this.processedProfiles = new LinkedList&lt;&gt;();
			this.activatedProfiles = false;
			this.loaded = new LinkedHashMap&lt;&gt;();
			initializeProfiles();
			while (!this.profiles.isEmpty()) {
				Profile profile = this.profiles.poll();
				if (profile != null &amp;&amp; !profile.isDefaultProfile()) {
					addProfileToEnvironment(profile.getName());
				}
				load(profile, this::getPositiveProfileFilter, addToLoaded(MutablePropertySources::addLast, false));
				this.processedProfiles.add(profile);
			}
			resetEnvironmentProfiles(this.processedProfiles);
			load(null, this::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, true));
			addLoadedPropertySources();
		}
</code></pre>
<p>我们主要看这个方法中的是三个方法：</p>
<ul>
<li>Loader#initializeProfiles</li>
<li>Loader#addProfileToEnvironment</li>
<li>Loader#load(Profile, DocumentFilterFactory, DocumentConsumer)</li>
</ul>
<p>第一个方法 initializeProfiles 初始化 Profiles，给 profiles 属性添加两个元素，null 和 默认的Profile。</p>
<p>第二个方法 addProfileToEnvironment 就是将 Profile 添加到 environment对象的 activeProfiles 里，也就是最开始日志打印的 activeProfiles。</p>
<p>第三个方法就是加载配置文件的数据源和Profies 相关的属性。</p>
<p>进入 load 方法，这个方法内部通过不同配置路径去尝试执行另一个 <code>load</code> 方法加载配置文件，这里name就是配所要搜索的配置文件名称，默认为 <code>application</code>。</p>
<pre><code class="language-java">		private void load(Profile profile, DocumentFilterFactory filterFactory, DocumentConsumer consumer) {
			getSearchLocations().forEach((location) -&gt; {
				boolean isFolder = location.endsWith(&quot;/&quot;);
				Set&lt;String&gt; names = isFolder ? getSearchNames() : NO_SEARCH_NAMES;
				names.forEach((name) -&gt; load(location, name, profile, filterFactory, consumer));
			});
		}
</code></pre>
<p>由于我们的配置文件在classPath下，所以只要留意当 location为 <code>classpath:/</code> 的程序执行情况即可。</p>
<pre><code class="language-java">private void load(String location, String name, Profile profile, DocumentFilterFactory filterFactory, DocumentConsumer consumer) {
			if (!StringUtils.hasText(name)) {
				for (PropertySourceLoader loader : this.propertySourceLoaders) {
					if (canLoadFileExtension(loader, location)) {
						load(loader, location, profile, filterFactory.getDocumentFilter(profile), consumer);
						return;
					}
				}
			}
			Set&lt;String&gt; processed = new HashSet&lt;&gt;();
			for (PropertySourceLoader loader : this.propertySourceLoaders) {
				for (String fileExtension : loader.getFileExtensions()) {
					if (processed.add(fileExtension)) {
						loadForFileExtension(loader, location + name, &quot;.&quot; + fileExtension, profile, filterFactory,
								consumer);
					}
				}
			}
		}
</code></pre>
<p>由于SpringBoot 配置文件支持xml，properties， yml 格式，就需要不同 PropertySourceLoader 支持其文件内容的加载：PropertiesPropertySourceLoader 支持 <code>xml</code>，<code>properties</code> 文件，YamlPropertySourceLoader 支持 yml 文件，加载以 <code>.yml</code> 或 <code>.yaml</code> 后缀的文件，<code>Loader#loadForFileExtension</code> 方法就完成了对这些配置文件的加载。</p>
<p>我们示例程序只有 properties 文件，所以只需要关注当 loader 为 PropertiesPropertySourceLoader时的 <code>Loader#loadForFileExtension</code> 方法的执行情况。</p>
<pre><code class="language-java">		private void loadForFileExtension(PropertySourceLoader loader, String prefix, String fileExtension, Profile profile, DocumentFilterFactory filterFactory, DocumentConsumer consumer) {
			DocumentFilter defaultFilter = filterFactory.getDocumentFilter(null);
			DocumentFilter profileFilter = filterFactory.getDocumentFilter(profile);
			if (profile != null) {
				// Try profile-specific file &amp; profile section in profile file (gh-340)
				String profileSpecificFile = prefix + &quot;-&quot; + profile + fileExtension;
				load(loader, profileSpecificFile, profile, defaultFilter, consumer);
				load(loader, profileSpecificFile, profile, profileFilter, consumer);
				// Try profile specific sections in files we've already processed
				for (Profile processedProfile : this.processedProfiles) {
					if (processedProfile != null) {
						String previouslyLoaded = prefix + &quot;-&quot; + processedProfile + fileExtension;
						load(loader, previouslyLoaded, profile, profileFilter, consumer);
					}
				}
			}
			// Also try the profile-specific section (if any) of the normal file
			load(loader, prefix + fileExtension, profile, profileFilter, consumer);
		}
</code></pre>
<p><code>loadForFileExtension</code> 内部调用另外一个加载配置文件的 load 方法，当读取到 classPath下的application.properties 时，会执行到  <code>Loader#loadDocuments</code> 方法，这个方法就是把配置文件作为文档进行加载，所有键值对配置都会以存在 PropertySource 之中,存储到 Document 对象中。</p>
<figure data-type="image" tabindex="7"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5x80ivld4j31rk0qg130.jpg" alt="image-20190812213458407"></figure>
<p>并且 documents 对象经过 Loader#asDocuments 方法关联上 <code>spring.profiles.active</code> 属性，profiles 属性添加一个定义为 <code>prod</code> 的 Profile，为后面的 Environment 对象添加 Profile 做准备，到这里默认的配置文件 <code>application.properties</code> 加载完毕了，方法又回到了 <code>Loader#load()</code> 上。</p>
<figure data-type="image" tabindex="8"><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5x8f0v0ynj31so0nmgrf.jpg" alt="image-20190812214903690"></figure>
<p>有了新添加的 Profile，继续进入循环，就会通过 <code>Loader#addProfileToEnvironment</code> 方法，为 environment 对象保存激活的 Profile，并且按照之前的逻辑，读取名为 <code>application-prod.properties</code> 的配置文件，命名方式可以从之前的 <code>Loader#loadForFileExtension</code> 的第462行就可以看出：</p>
<pre><code class="language-java">String profileSpecificFile = prefix + &quot;-&quot; + profile + fileExtension;
</code></pre>
<p>在 <code>Loader#load()</code>  方法读取了所有配置文件后，执行 <code>Loader#addLoadedPropertySources</code>，将对应属性源 PropertySource 存储到 environment 对象中，并且 <code>application-prod.properties</code> 顺序先于默认配置文件，就是为了后面程序应用相同名称配置的时候，优先采用元素位置在前的配置。</p>
<figure data-type="image" tabindex="9"><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5x8qqyxu6j32110u0nb2.jpg" alt="image-20190812220023086"></figure>
<p>至此，所有配置文件上的数据加载完存储到了与当前上下文关联的  environment 对象中，将 prod 作为 Active Profile 激活特定环境配置的工作就完成了。</p>
<h1 id="小结">小结</h1>
<p>虽然只是探究 Spring Boot 程序如何加载和应用 Profile，但通过这次源码分析，我们可以发现 SpringBoot 虽简单易用，但是内部实现逻辑设计是比较复杂的，无论是资源的加载，数据的解析都有专门的组件类去处理，大量使用事件通知和设计模式，在分析源码时少不了一次又一次的运行断点，不过这需要我们充分利用DE工具调试功能，在错综复杂的代码中能更准确地定位目标。</p>
<figure data-type="image" tabindex="10"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5ycjg3nbqj30p00dwjym.jpg" alt=""></figure>
<h2 id="推荐阅读">推荐阅读</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/TfA8rSwYNpW3YV_N8oLJnw">一文掌握 Spring Boot Profiles</a></li>
<li><a href="https://mp.weixin.qq.com/s/-t2hrrVMBpPmVEzDcC8J5w">如何优雅关闭 Spring Boot 应用</a></li>
<li><a href="https://mp.weixin.qq.com/s/uWRnRhH4et-XSD101Xh6LQ">需要接口管理的你了解一下？</a></li>
<li><a href="https://mp.weixin.qq.com/s/2qkNz4VPgnixXjaVYUkvvQ">Java 之 Lombok 必知必会</a></li>
<li><a href="https://mp.weixin.qq.com/s/vS36glyNoD26GL6cbNs5Qw">Java 微服务新生代之 Nacos</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一文掌握 Spring Boot Profiles]]></title>
        <id>https://wrcj12138aaa.github.io//post/20190728-一文掌握 Spring Boot Profiles</id>
        <link href="https://wrcj12138aaa.github.io//post/20190728-一文掌握 Spring Boot Profiles">
        </link>
        <updated>2019-07-28T10:33:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="spring-boot-profiles-简介">Spring Boot Profiles 简介</h2>
<p>Profile 的概念其实很早在 Spring Framework 就有了，在  Spring Framework 3.1 版本引入了注解 <code>@Profile</code> 和 <code>Environment</code> 环境配置的抽象，只是在 Spring Boot 框架里再进一步将 Profiles 功能进行扩展，使它也成为了 Spring Boot 特性之一，为此单独在 <a href="https://docs.spring.io/spring-boot/docs/2.1.4.RELEASE/reference/htmlsingle/#boot-features-profiles">官方文档 25. Profiles</a> 一节里介绍，文档里把 Spring Boot Profiles 也叫做 Spring Profiles。</p>
<p>那么什么又是 Spring Profiles，为什么需要它呢？我们先来看一个熟悉的场景：我们平常项目开发，经常需要根据不同的环境进行配置的修改，比如在本地开发会加载本机的配置和开发环境数据库，在测试服务器上部署时就需要加载测试环境配置和数据库，同样地，当项目发布生产环境时就需要设置为生产环境配置和数据库。这样一来，不同的环境部署都需要额外的处理来调整环境的配置，维护起来十分繁琐，还容易出错。</p>
<p>为了解决不同环境需要的配置切换问题，Spring Profiles 提供了一种方式允许我们指定在特定环境下只加载对应的程序配置，每一种环境配置对应一个 Profile，只有当前 Profile 处于激活状态时，才会将该 Profile 所对应的配置和 Bean 加载到 Spring 程序中。</p>
<blockquote>
<p><strong>Spring Profiles 就是针对应用程序，不同环境需要不同配置加载的一种解决方案。</strong></p>
</blockquote>
<p>当然 Spring 允许多个 Profile 处于激活状态，比如将应用配置进行细分成数据库配置，消息中间件配置，缓存配置等，都为各自在不同环境定义不同的 Profile 名称，在需要激活环境对应配置时，指定多个 Profile。</p>
<h2 id="spring-profiles-实战">Spring  Profiles 实战</h2>
<p>在 Spring 程序中有两种方式使用 Profiles：XML 配置和注解 <code>@Profile</code>。</p>
<h3 id="xml-配置定义-profile">XML 配置定义 Profile</h3>
<p>虽然现在 XML 配置方式使用越来越少，还是简单介绍下，通常我们在 XML 文件定义的 Bean 时都有根元素 <code>&lt;beans&gt;</code>，在 <code>beans</code> 元素上多了一个属性 <code>profile</code> 可以指定环境，比如说把开发环境的 <code>profile</code> 定义为 dev,生产环境的 <code>profile</code> 为：prod。</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;beans profile=&quot;dev&quot;&gt;
        &lt;bean id=&quot;city&quot; class=&quot;com.one.learn.springboot.actions.profiles.domain.City&quot;&gt;
            &lt;constructor-arg name=&quot;name&quot; type=&quot;java.lang.String&quot; value=&quot;beijing&quot;/&gt;
            &lt;constructor-arg name=&quot;postCode&quot; type=&quot;java.lang.String&quot; value=&quot;100000&quot;/&gt;
        &lt;/bean&gt;
    &lt;/beans&gt;
    &lt;beans profile=&quot;prod&quot;&gt;
        &lt;bean id=&quot;city&quot; class=&quot;com.one.learn.springboot.actions.profiles.domain.City&quot;&gt;
            &lt;constructor-arg name=&quot;name&quot; type=&quot;java.lang.String&quot; value=&quot;shanghai&quot;/&gt;
            &lt;constructor-arg name=&quot;postCode&quot; type=&quot;java.lang.String&quot; value=&quot;200000&quot;/&gt;
        &lt;/bean&gt;
    &lt;/beans&gt;
&lt;/beans&gt;
</code></pre>
<p>需要注意的是：必须要使用 Spring XML Beans Schema 版本为 4.0 以上才支持 <code>profile</code> 属性。在 XML 文件定义之后我们只需要激活指定的 Profile 名称就可以加载对应的 Bean 对象了，在 Spring 程序中激活的方式主要两种：</p>
<ul>
<li>
<p>Java API 方式，获取当前 Spring 容器的环境 Bean，设置 <code>activeProfiles</code> 属性，然后启动容器</p>
<pre><code class="language-java">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles(&quot;dev&quot;);
ctx.refresh();
</code></pre>
</li>
</ul>
<ul>
<li>采用启动参数方式指定，固定格式：<code>-Dspring.profiles.active=dev</code></li>
</ul>
<h3 id="注解-profiles-定义profile">注解 @Profiles 定义Profile</h3>
<p>使用注解定义 Profile 也比较简单，引入一个新的注解  <code>@Profiles</code>，通常 <code>@Profiles</code> 配合 <code>@Component</code> 或者 <code>@Configuration</code> 使用，如下示例：</p>
<pre><code class="language-java">// DevConfig.java
@Configuration
@Profile(&quot;dev&quot;)
public class DevConfig {
    @Bean
    public City city() {
        return new City(&quot;beijing&quot;, &quot;100000&quot;);
    }
}

// ProdConfig.java
@Configuration
@Profile(&quot;prod&quot;)
public class ProdConfig {
    @Bean
    public City city() {
        return new City(&quot;shanghai&quot;, &quot;200000&quot;);
    }
}
</code></pre>
<p>激活 Profile 的方式都是一样的，只要指定 Profile 被激活，其对应的 Bean 才会加载。在 Spring 程序中 Profile 默认为 default，当前我们可以通过 <code>spring.profiles.default</code> 配置方式或者 <code>org.springframework.core.env.AbstractEnvironment#setDefaultProfiles</code> API 方式修改。</p>
<h2 id="spring-boot-profile-实战">Spring Boot Profile 实战</h2>
<p>好了，现在我们再来看下在 Spring Boot 程序中如何使用 Profile。通常一个 Spring Boot 程序的配置文件为 yml 或者 properties 格式，由于 yml 格式文件的结构简洁已读，备受官方推崇，我们可以看下如何在 <code>application.yml</code> 定义 Profile 和对应的配置。</p>
<pre><code class="language-yml">server:
  port: 9000
---
spring:
  profiles: dev
app:
  enviroment: dev
---
spring:
  profiles: prod
app:
  enviroment: prod
</code></pre>
<p>与yml格式文件不同，正对不同的 Profile，无法在一个 properties 文件设置，官方采用命名形式为  <code>applications-${profile}.properties</code> 格式来达成一样的效果。为了看到指定 Profile 激活后的效果，我们可以通过下方的一个例子实践下，通过激活不同 Profile 启动程序，来请求 <code>/enviroment</code> 接口来获取当前的环境配置变量。</p>
<pre><code class="language-java">@RestController()
public class ProfileController {
    @Value(&quot;${app.enviroment}&quot;)
    private String enviroment;

    @GetMapping(&quot;/enviroment&quot;)
    public String enviroment() {
        return &quot;current app enviroment is &quot; + enviroment;
    }
}
</code></pre>
<p>这里我们介绍如何在配置文件中激活 Profile 的方式：在 <code>application.yml</code> 顶部添加如下配置，表明当前所激活的 Profile 为 prod，当然也可以前文介绍的启动参数方式激活：</p>
<pre><code class="language-yaml">spring:
  profiles:
    active: prod
</code></pre>
<p>然后启动程序，curl 方式访问 <code>http://localhost:9000/enviroment</code> 可以得到如下输出结果：</p>
<pre><code class="language-shell">curl http://localhost:9000/enviroment
current app enviroment is prod
</code></pre>
<p>同样如果上述的 <code>active</code> 属性值指定为 <code>dev</code>，将输出内容： <code>current app enviroment is prod</code>。</p>
<h3 id="spring-boot-api-方式激活-profile">Spring Boot API 方式激活 Profile</h3>
<p>在 Spring Boot 程序除了上述的方法来激活 Profile 外，还可以使用 Spring Boot API 方式激活：</p>
<ul>
<li>
<p><code>SpringApplication.setAdditionalProfiles(…)</code></p>
<pre><code class="language-java">SpringApplication springApplication = new SpringApplication(SpringbootActionsProfilesApplication.class);
springApplication.setAdditionalProfiles(&quot;prod&quot;);
springApplication.run(args);
</code></pre>
</li>
<li>
<p><code>SpringApplicationBuilder.profiles(...)</code></p>
<pre><code class="language-java">SpringApplicationBuilder builder = new SpringApplicationBuilder(SpringbootActionsProfilesApplication.class);
builder.profiles(&quot;prod&quot;).run(args);
</code></pre>
</li>
</ul>
<p>但需要注意的是使用 Spring Boot API 的话需要在程序启动前设置，也就是 <code>SpringApplication.run(...)</code> 方法执行前，否则没有效果。 采用 Spring Boot API 方式添加的Profile 是属于额外激活的 Profile，也就是说覆盖掉外部传入的 <code>spring.profiles.activie</code> 指定的 Profile。</p>
<h2 id="总结">总结</h2>
<p>在Spring Boot 程序中，我们通常定义不同 Profiles 的配置文件，如 <code>application-{profile}.properties</code>，在默认配置文件 <code>application.properties</code> 中设置 <code>spring.profiles.active=dev</code> ，用于平常开发使用，当需要打包上传服务器时，通过启动参数方式 <code>jar -Dspring.profiles.active=prod xxx.jar</code>  指定对应环境的 Profile 启动程序来加载对应环境的配置，到这里我们学习如何通过 Spring Boot Profiles 特性来应对程序中不同环境配置的切换，希望对工作中的小伙伴有所帮助，也欢迎小伙伴留言分享应对项目环境配置区分加载的实践心得。若有错误或者不当之处，还请大家批评指正，一起学习交流。</p>
<blockquote>
<p>下篇文章将通过解读源码的方式具体讲解 Spring Boot Profiles 实现原理，敬请关注期待。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5fq7eonnaj30p00dwahn.jpg" alt=""></figure>
<h2 id="示例代码">示例代码</h2>
<p>本文示例代码可以通过下面仓库地址获取：</p>
<ul>
<li>springboot-actions-profiles：https://github.com/wrcj12138aaa/springboot-actions-profiles</li>
</ul>
<p>环境支持：</p>
<ul>
<li>JDK 8</li>
<li>SpringBoot 2.1.6</li>
<li>Maven 3.6.0</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>How to use profiles in Spring Boot Application：http://1t.click/yUj</li>
<li>Spring Boot Doc：http://1t.click/yUh</li>
<li>Spring Doc：http://1t.click/yUg</li>
<li>全面解读 Spring Profile 的用法：https://mp.weixin.qq.com/s/0iWpGefYPqnkly4EmaPAug</li>
</ul>
<h2 id="推荐阅读">推荐阅读</h2>
<ul>
<li>
<p><a href="https://mp.weixin.qq.com/s/-t2hrrVMBpPmVEzDcC8J5w">如何优雅关闭 Spring Boot 应用</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/2qkNz4VPgnixXjaVYUkvvQ">Java 之 Lombok 必知必会</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/vS36glyNoD26GL6cbNs5Qw">Java 微服务新生代之 Nacos</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/GCjXZybnweHNKi0dVpR46A">Java 微服务新生代 Nacos 之配置管理</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/9zrcG2Bar6VkcS8brRIx2g">掌握设计模式之适配器模式</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何优雅关闭 Spring Boot 应用]]></title>
        <id>https://wrcj12138aaa.github.io//post/20190721-如何优雅关闭 Spring Boot 应用</id>
        <link href="https://wrcj12138aaa.github.io//post/20190721-如何优雅关闭 Spring Boot 应用">
        </link>
        <updated>2019-07-21T10:52:20.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g57nkcvtv9j31900u0e83.jpg" alt=""></figure>
<h2 id="前言">前言</h2>
<p>随着线上应用逐步采用 SpringBoot 构建，SpringBoot应用实例越来多，当线上某个应用需要升级部署时，常常简单粗暴地使用 kill 命令，这种停止应用的方式会让应用将所有处理中的请求丢弃，响应失败。这样的响应失败尤其是在处理重要业务逻辑时需要极力避免的，那么有什么更好的方式来平滑地关闭 SpringBoot 应用呢？那就通过本文一起来探究吧。（本文主要针对基于Spring Boot 内嵌 Tomcat 容器作为 Web 服务的应用）</p>
<blockquote>
<p>本文示例代码可以通过下面仓库地址获取：</p>
<ul>
<li>springboot-shutdown：https://github.com/wrcj12138aaa/springboot-shutdown</li>
</ul>
<p>环境支持：</p>
<ul>
<li>JDK 8</li>
<li>SpringBoot 2.1.4</li>
<li>Maven 3.6.0</li>
</ul>
</blockquote>
<h2 id="定制-tomcat-connector-行为">定制 Tomcat Connector 行为</h2>
<p>要平滑关闭 Spring Boot 应用的前提就是首先要关闭其内置的 Web 容器，不再处理外部新进入的请求。为了能让应用接受关闭事件通知的时候，保证当前 Tomcat 处理所有已经进入的请求，我们需要实现 TomcatConnectorCustomizer 接口，这个接口的源码十分简单，从注释可以看出这是实现自定义 Tomcat Connector 行为的回调接口：</p>
<pre><code class="language-java">/**
 * Callback interface that can be used to customize a Tomcat {@link Connector}.
 *
 * @author Dave Syer
 * @see ConfigurableTomcatWebServerFactory
 * @since 2.0.0
 */
@FunctionalInterface
public interface TomcatConnectorCustomizer {

	/**
	 * Customize the connector.
	 * @param connector the connector to customize
	 */
	void customize(Connector connector);

}
</code></pre>
<p>这里如果小伙伴对 Connector 不太熟悉，我就简单描述下： Connector 属于 Tomcat 抽象组件，功能就是用来接受外部请求，以及内部传递，并返回响应内容，是Tomcat 中请求处理和响应的重要组件，具体实现有 HTTP Connector 和 AJP Connector。</p>
<p>通过定制 Connector 的行为，我们就可以允许在请求处理完毕后进行 Tomcat 线程池的关闭，具体实现代码如下：</p>
<pre><code class="language-java">@Slf4j
public class CustomShutdown implements TomcatConnectorCustomizer, ApplicationListener&lt;ContextClosedEvent&gt; {

    private static final int TIMEOUT = 30;

    private volatile Connector connector;

    @Override
    public void onApplicationEvent(ContextClosedEvent event) {
        //暂停接受外部的所有新请求
        this.connector.pause(); 
        //获取 Connector 对应的线程池
        Executor executor = this.connector.getProtocolHandler().getExecutor(); 
        if (executor instanceof ThreadPoolExecutor) {
            try {
                log.warn(&quot;WEB 应用准备关闭&quot;);
                ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executor;
                //初始化一个关闭任务位于当前待处理完毕的任务之后，并拒绝新的任务提交。
                threadPoolExecutor.shutdown();
                if (!threadPoolExecutor.awaitTermination(TIMEOUT, TimeUnit.SECONDS)) { 
                    //等待前一个已提交的任务执行完成后关闭，并且仅在最大等待时间内进行
                    log.warn(&quot;WEB 应用等待关闭超过最大时长 &quot; + TIMEOUT + &quot; 秒，将进行强制关闭!&quot;);
                    threadPoolExecutor.shutdownNow(); //尝试强制关闭线程池
                    if (!threadPoolExecutor.awaitTermination(TIMEOUT, TimeUnit.SECONDS)) {
                        log.error(&quot;WEB 应用关闭失败!&quot;);
                    }
                }
            } catch (InterruptedException ex) {
                Thread.currentThread().interrupt();
            }
        }
    }

    @Override
    public void customize(Connector connector) {
        this.connector = connector;
    }
}
</code></pre>
<p>上述代码定义的 TIMEOUT 变量为 Tomcat 线程池延时关闭的最大等待时间，一旦超过这个时间就会强制关闭线程池，也就无法处理所有请求了，我们通过控制 Tomcat 线程池的关闭时机，来实现优雅关闭 Web 应用的功能。另外需要注意的是我们的类 CustomShutdown 实现了 ApplicationListener<ContextClosedEvent> 接口，意味着监听着 Spring 容器关闭的事件，即当前的 ApplicationContext 执行 close 方法。</p>
<p>##内嵌 Tomcat 添加 Connector 回调</p>
<p>有了定制的 Connector 回调，我们需要在启动过程中添加到内嵌的 Tomcat 容器中，然后等待执行。那这一步又是如何实现的呢，可以参考下面代码：</p>
<pre><code class="language-java">@Bean
public CustomShutdown customShutdown() {
    return new CustomShutdown();
}

@Bean
public ConfigurableServletWebServerFactory webServerFactory(final CustomShutdown customShutdown) {
    TomcatServletWebServerFactory tomcatServletWebServerFactory = new TomcatServletWebServerFactory();
    tomcatServletWebServerFactory.addConnectorCustomizers(customShutdown);
    return tomcatServletWebServerFactory;
}
</code></pre>
<p>这里的 TomcatServletWebServerFactory 是 Spring Boot 实现内嵌 Tomcat 的工厂类，类似的其他 Web 容器，也有对应的工厂类如 JettyServletWebServerFactory，UndertowServletWebServerFactory。他们共同的特点就是继承同个抽象类 AbstractServletWebServerFactory，提供了 Web 容器默认的公共实现，如应用上下文设置，会话管理等。</p>
<p>如果我们需要定义Spring Boot 内嵌的 Tomcat 容器时，就可以使用 TomcatServletWebServerFactory 来进行个性化定义，例如下方为官方文档提供自定示例：</p>
<pre><code class="language-java">@Bean
public ConfigurableServletWebServerFactory webServerFactory() {
	TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
	factory.setPort(9000);
	factory.setSessionTimeout(10, TimeUnit.MINUTES);
	return factory;
}
</code></pre>
<p>好了说回正题，我们这里使用 <code>addConnectorCustomizers</code> 方法将自定义的 Connector 行为添加到内嵌的Tomcat 之上，为了查看加载效果，我们可以在 Spring Boot 程序启动后从容器中获取下webServerFactory  对象，然后观察，在它的 tomcatConnectorCustomizers 属性中可以看到已经有了 CustomeShutdown 对象。</p>
<figure data-type="image" tabindex="2"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g57hk8irurj31ha0mawjk.jpg" alt=""></figure>
<h2 id="开启-shutdown-endpoint">开启 Shutdown Endpoint</h2>
<p>到目前让内嵌 Tomcat 容器平稳关闭的操作已经完成，接下来要做的就是如何关闭主动关闭 Spring 容器了，除了常规Linux 命令 Kill，我们可以利用 Spring Boot Actuator 来实现Spring 容器的远程关闭，怎么实现继续看</p>
<p>Spring Boot Actuator 是 Spring Boot 的一大特性，它提供了丰富的功能来帮助我们监控和管理生产环境中运行的 Spring Boot 应用。我们可以通过 HTTP 或者 JMX 方式来对我们应用进行管理，除此之外，它为我们的应用提供了审计，健康状态和度量信息收集的功能，能帮助我们更全面地了解运行中的应用。</p>
<blockquote>
<p><strong>Actuator</strong>， ['æktʃʊˌeɪtə]  中文翻译过来就是<strong>制动器</strong>，这是一个制造业的术语，指的是用于控制某物的机械装置。</p>
</blockquote>
<p>在 Spring Boot Actuator 中也提供控制应用关闭的功能，所以我们要为应用引入 Spring Boot Actuator，具体方式就是要将对应的 starter 依赖添加到当前项目中，以 Maven 项目为例：</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
  &lt;version&gt;${version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>Spring Boot Actuator 采用向外部暴露 Endpoint (端点)的方式来让我们与应用进行监控和管理，引入 <code>spring-boot-starter-actuator</code> 之后，我们就需要启用我们需要的 Shutdown Endpoint，在配置文件 application.properties 中，设置如下:</p>
<pre><code class="language-properties">management.endpoint.shutdown.enabled=true
management.endpoints.web.exposure.include=*
</code></pre>
<p>第一行表示启用 Shutdown Endpoint ，第二行表示向外部以 HTTP 方式暴露所有 Endpoint，默认情况下除了 Shutdown Endpoint 之外，其他 Endpoint 都是启用的。</p>
<blockquote>
<p>除了  Shutdown Endpoint，Actuator Endpoint 还有十余种，有的是特定操作，比如 <code>heapdump</code> 转储内存日志；有的是信息展示，比如 <code>health</code> 显示应用健康状态。具体所有 Endpoint 信息可以参见<a href="https://docs.spring.io/spring-boot/docs/2.1.4.RELEASE/reference/htmlsingle/#production-ready-endpoints">官方文档-53. Endpoints</a> 一节。</p>
</blockquote>
<p>到这里我们的前期配置工作就算完成了。当启动应用后，就可以通过POST 方式请求对应路径的 <code>http://host:port/actuator/shutdown</code> 来实现Spring Boot 应用远程关闭，是不是很简单呢。</p>
<h2 id="模拟测试">模拟测试</h2>
<p>这里为了模拟测试，我们首先模拟实现长达10s 时间处理业务的请求控制器 BusinessController，具体实现如下：</p>
<pre><code class="language-java">@Slf4j
@RestController
public class BusinessController {

    @RequestMapping(&quot;/working&quot;)
    public String working() throws InterruptedException {
        log.warn(&quot;开始处理业务&quot;);
        Thread.sleep(10000);
        log.warn(&quot;结束处理业务&quot;);
        return &quot;业务完成&quot;;
    }
}
</code></pre>
<p>用 <code>Thread.sleep</code> 来阻塞当前请求线程，模拟业务处理，在此同时用 HTTP 方式访问 Shutdown Endpoint 试图关闭应用，可以通过观察控制台日志看是否应用是否会完成请求的处理后才真正进行关闭。</p>
<p>首先用 curl 命令模拟发送业务请求：</p>
<pre><code class="language-shell">curl http://localhost:8080/working
</code></pre>
<p>然后在业务处理中，直接发送请求 <code>actuator/shutdown</code>,尝试关闭应用，同样采用 curl 方式：</p>
<pre><code class="language-shell">curl -X POST http://localhost:8080/actuator/shutdown
</code></pre>
<p><code>actuator/shutdown</code> 请求发送后会立即返回响应结果，但应用并不会停止：</p>
<pre><code class="language-shell">{&quot;message&quot;:&quot;Shutting down, bye...&quot;}     
</code></pre>
<p>最后看下控制台的日志输出顺序：</p>
<figure data-type="image" tabindex="3"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g57ivv2lrsj31xm08kad4.jpg" alt=""></figure>
<p>可以看出在发送业务请求之后立刻发送关闭应用的请求，并不会立即将应用停止，而是在请求处理完毕之后，就是阻塞的 10s 后应用开始退出，这样可以保证已经接收到的请求能返回正常响应, 而关闭请求之后再进入的请求都不会被处理，到这里我们优雅关闭 Spring Boot 程序的操作就此实现了。</p>
<h2 id="实现自动化">实现自动化</h2>
<p>由于 Spring Boot 提供内嵌 Web 容器的便利性，我们经常将程序打包成 jar 然后发布。通常应用的启动和关闭操作流程是固定且重复的，本着 Don't Repeat Yourself 原则，我们有必要将这个操作过程自动化，将关闭和启用的 SpringBoot应用的操作写成 shell 脚本，以避免出现人为的差错，并且方便使用，提高操作效率。下面是我针对示例程序所写的程序启动脚本：</p>
<pre><code class="language-shell">#!/bin/bash
# 平滑关闭和启动 Spring Boot 程序
#设置端口
SERVER_PORT=&quot;8081&quot;
#设置应用名称
JAR_NAME=&quot;springboot-shutdown-0.0.1-SNAPSHOT&quot;
#设置 JAVA 启动参数
JAVA_OPTIONS=&quot;-server -Xms1024M -Xmx1024M -Dserver.port=$SERVER_PORT&quot;

#Actuator 方式远程关闭应用
curl -X POST &quot;http://localhost:$SERVER_PORT/actuator/shutdown&quot;
echo &quot;&quot;
#循环遍历应用端口是否被使用，作为应用运作状态的标志
echo &quot;关闭旧应用开始&quot;
UP_STATUS=1
while(( $UP_STATUS&gt;0 ))
do
    UP_STATUS=$(lsof -i:&quot;$SERVER_PORT&quot; | wc -l)
done
echo &quot;\n关闭旧应用结束&quot;
echo &quot;启动应用开始&quot;
#非挂起方式启动应用，并且跟踪启动日志文件
nohup&gt;&quot;$SERVER_PORT&quot;.log java -jar &quot;$JAVA_OPTIONS&quot; &quot;$JAR_NAME&quot;.jar 2&gt;&amp;1 &amp;
echo &quot;启动应用中&quot; &amp;&amp; tail -20f &quot;$SERVER_PORT&quot;.log
</code></pre>
<p>有了脚本，我们可以直接通过命令行方式平滑地更新部署 Spring Boot 程序，效果如下：</p>
<figure data-type="image" tabindex="4"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g57kxoe72fj31wm0o4wzi.jpg" alt=""></figure>
<h2 id="总结">总结</h2>
<p>本文主要探究了如何对基于Spring Boot 内嵌 Tomcat 的 Web 应用进行平滑关闭的实现，如果采用其他 Web 容器也类似方式，希望这边文章有所帮助，若有错误或者不当之处，还请大家批评指正，一起学习交流。</p>
<figure data-type="image" tabindex="5"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g57n4roxy6j30p00dwaim.jpg" alt=""></figure>
<h2 id="参考">参考</h2>
<ul>
<li>Graceful Shutdown Spring Boot Applications：https://blog.marcosbarbero.com/graceful-shutdown-spring-boot-apps/</li>
<li>Shutdown a Spring Boot Application：https://www.baeldung.com/spring-boot-shutdown</li>
<li>官方文档-53. Endpoints：https://docs.spring.io/spring-boot/docs/2.1.4.RELEASE/reference/htmlsingle/#production-ready-endpoints</li>
<li>The HTTP Connector：https://tomcat.apache.org/tomcat-8.5-doc/config/http.html</li>
<li>Customizing ConfigurableServletWebServerFactory Directly：https://docs.spring.io/spring-boot/docs/2.1.4.RELEASE/reference/htmlsingle/#boot-features-customizing-configurableservletwebserverfactory-directly</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[掌握设计模式之装饰者模式]]></title>
        <id>https://wrcj12138aaa.github.io//post/20190714-掌握设计模式之装饰者模式</id>
        <link href="https://wrcj12138aaa.github.io//post/20190714-掌握设计模式之装饰者模式">
        </link>
        <updated>2019-07-14T15:05:20.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4ztauvhzej30p00dw45p.jpg" alt=""></figure>
<h2 id="前言">前言</h2>
<p>当应用开发中,我们要为一个对象在原有功能上进行扩展增强时,往往采用继承的方式,而继承过多时就会使得功能类更加复杂,不利于维护,而设计模式中装饰者模式可以帮助我们更好对应这种场景,装饰者模式可以做到让对象能够动态地进行功能扩展,而不影响其他对象. 那究竟它是如何实现的呢，又如何实际应用呢，就让我们一起来学习下这个模式吧。</p>
<h2 id="正文">正文</h2>
<h3 id="模式定义">模式定义</h3>
<p>装饰者模式属于结构型设计模式，首先我们先了解下装饰者模式的定义。</p>
<blockquote>
<p>In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class. The decorator pattern is often useful for adhering to the Single Responsibility Principle, as it allows functionality to be divided between classes with unique areas of concern.</p>
</blockquote>
<p>简而言之, 装饰者模式就是动态地为一个对象扩展额外的功能,无论是动态还是静态,都不影响相同类的其他对象的行为, 这样使得对象在运行时更加灵活。</p>
<p>装饰者实现的方式通常为组合或者继承,可以让客户端根据需求进行对应的装饰，来达到功能增加的目标。为了简化理解，装饰者模式中装饰一词其实就是给原来的对象添加额外功能。</p>
<h3 id="模式结构">模式结构</h3>
<p>接下来我们看下装饰者模式的层次结构和主要角色.</p>
<figure data-type="image" tabindex="2"><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwwvgxjzzbj30fs0aht9o.jpg" alt="image-20181105081809413"></figure>
<ul>
<li><code>Component</code> 抽象组件,最原始,核心的对象,通常为接口或者抽象类.</li>
<li><code>ConcreteComponent</code> 具体组件,对 <code>Component</code> 的实现,也是需要装饰的对象.</li>
<li><code>Decorator</code> 装饰者, 通常为抽象组件的抽象实现, 它的属性一定有私有变量指向 <code>Component</code>.</li>
<li><code>ConcreteDecorator</code> 具体装饰对象,是 <code>Decorator</code> 的具体实现, 用于将原始,核心的方法装饰增强的类.</li>
</ul>
<p>从图中看到，接口 <code>Component</code> 会有对应的实现类 <code>ConcerateComponent</code>，要对具体实现类进行功能增强，就需要对应的具体装饰者 <code>ConcreteDecorator</code> ，它通过内部引用  <code>Component</code> 类型的 <code>ConcerateComponent</code> 对象 ，在接口方法的默认实现上，允许添加额外的逻辑和功能代码。</p>
<h3 id="模式实现">模式实现</h3>
<p>现在我们用喝咖啡的例子来实现下装饰者模式，假设我们要买一杯咖啡，需要加糖，加奶，而什么都不加的咖啡与加奶,加糖的价格都不一样，我们就要计算调制一杯加糖加奶的咖啡需要花费多少钱。</p>
<p>这里咖啡就是我们的具体组件 <code>ConcerateComponent</code>, 奶和糖就是具体装饰对象 <code>ConcreteDecorator</code>。 为了简单,我们先创建一个<code>Component</code>接口类 <code>Drink</code>, 定义两个方法用来获得价格和描述：</p>
<pre><code class="language-java">interface Drink {
    float cost();
    String getDescription();
}
</code></pre>
<p>接着,创建一个 <code>ConcreteComponent</code> 类 <code>Coffee</code> 实现 <code>Drink</code> 接口.</p>
<pre><code class="language-java">class Coffee implements Drink {

    @Override
    public float cost() {
        return 25;
    }

    @Override
    public String getDescription() {
        return &quot;it's coffee &quot;;
    }
}
</code></pre>
<p>现在就需要一个抽象类 <code>DrinkDecorator</code>,用于扩展实现功能增强.</p>
<pre><code class="language-java">class abstract DrinkDecorator implements Drink {
    private Drink drink;
    
    public DrinkDecorator(Drink drink) {
        this.drink = drink;
    }
    
    @Override
    public float cost() {
        return drink.cost();
    }

    @Override
    public String getDescription() {
        return drink.getDescription();
    }
}
</code></pre>
<p>然后就是实现具体装饰对象 <code>Milk</code> 和 <code>Sugar</code>.</p>
<pre><code class="language-java">class Milk extends DrinkDecorator {

    public Milk(Drink drink) {
        super(drink);
    }

    @Override
    public float cost() {
        return super.cost() + 3;
    }

    @Override
    public String getDescription() {
        return super.getDescription() + &quot;with milk &quot;;
    }
}

class Sugar extends DrinkDecorator {

    public Sugar(Drink drink) {
        super(drink);
    }

    @Override
    public float cost() {
        return super.cost() + 3;
    }

    @Override
    public String getDescription() {
        return super.getDescription() + &quot;with sugar &quot;;
    }
}
</code></pre>
<p>最后客户端实现买咖啡这个动作:</p>
<pre><code class="language-java">public class DecoratorLab {
    public static void main(String[] args) {
        Drink coffee = new Coffee(); 
        System.out.println(coffee.getDescription() + &quot;,cost:&quot; + coffee.cost());//it's coffee,cost:25.0
        coffee = new Milk(coffee);
        System.out.println(coffee.getDescription() + &quot;,cost:&quot; + coffee.cost());		//it's coffee with milk,cost:28.0
        coffee = new Sugar(coffee);
        System.out.println(coffee.getDescription() + &quot;,cost:&quot; + coffee.cost());//it's coffee with milk with sugar,cost:31.0
    }
}
</code></pre>
<p>下图为示例的类图：</p>
<figure data-type="image" tabindex="3"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4zsk8axpmj313e0og40u.jpg" alt=""></figure>
<p>可以从上面例子看出,通过添加不同的材料,价格不同,并且描述信息也不一样,并且添加顺序可以动态改变,甚至不添加,让对象变得十分灵活, 这就是装饰者模式的精髓所在。</p>
<h3 id="装饰者模式使用场景">装饰者模式使用场景</h3>
<p>装饰者模式同样大量应用在 JDK 源码中,我们经常可以看到:</p>
<ul>
<li>JDK 的 IO 操作类, 比如 <a href="http://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html">java.io.InputStream</a> 体系下  <code>FilterInputStream</code> 的一系列实现类，比如 <code>BufferedInputStream</code>，<code>LineNumberInputStream</code>，<code>DataInpuStream</code>。</li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedCollection-java.util.Collection-">java.util.Collections#synchronizedXXX()</a></li>
</ul>
<p>装饰者模式可以让程序中对象在运行时中进行功能的增强和移除，并且采用更灵活的组合方式来进行扩展。</p>
<h3 id="模式的得与失">模式的得与失</h3>
<p><strong>优点</strong>:</p>
<ul>
<li>在不影响其他对象的情况下,动态为单个对象新增功能。</li>
<li>装饰类与被装饰类 (<code>ConcreteComponent</code>) 相互独立,互不耦合,易于扩展。</li>
<li>代替继承方式的功能实现,减少继承类的存在。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>
<p>装饰层次过多时会让被装饰的对象更复杂，不容易理解，比如使用 Java I/O 的 <code>DataInputStream</code> 对象读取数据为 Java 基本类型值时会这样使用：</p>
<pre><code class="language-java">DataInputStream is = new DataInputStream(new BufferedInputStream(new FileInputStream(file)));
</code></pre>
</li>
<li>
<p>程序中若有太多的装饰类，理解和使用上略有难度。</p>
</li>
</ul>
<h2 id="结语">结语</h2>
<p>掌握装饰者模式的精髓在于通过一层层的包装,让原来对象的功能更加强大,且包装过程是动态的,灵活可以移除的,到最后还是会调用到原对象最原始的功能。</p>
<h3 id="参考">参考</h3>
<ul>
<li>https://www.journaldev.com/1540/decorator-design-pattern-in-java-example</li>
<li>https://java-design-patterns.com/patterns/decorator/</li>
<li>《设计模式之禅》：https://book.douban.com/subject/4260618/</li>
<li>https://javadoop.com/post/design-pattern</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[YApi使用指南]]></title>
        <id>https://wrcj12138aaa.github.io//post/20190707-YApi使用指南</id>
        <link href="https://wrcj12138aaa.github.io//post/20190707-YApi使用指南">
        </link>
        <updated>2019-07-07T07:00:20.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g4r7dbwihmj30jg0a83yy.jpg" alt="API"></figure>
<h2 id="前言">前言</h2>
<p>在日常的开发模式里，前端负责页面和动态脚本的处理，服务端负责业务逻辑和接口的实现。当前端需要服务端提供的接口实现动态数据展示和交互时，服务端完成接口开发后会提供一个接口文档给到前端按照文档规范再进行开发。这样模式下往往会出现两种情况：一种是往前端开发的进度往与服务端开发的进度不会完全同步，这就存在了一方等待另一方的情况，这多少会影响整体项目开发进度；另一种就是当前端对接不同的服务端人员所开发的接口，如果没有了统一的接口文档规范，每个人输出的接口文档都不尽相同，在后期对项目接口的更新和维护会是很大的时间成本。</p>
<p>所以很有必要有一个前后端通用的接口管理平台，简化接口对接和维护的流程。前后端可以通过接口管理平台，制定接口数据和格式，然后通过模拟数据生成假接口，前后端再各自独立开发，直至双方都开发完成后对接真实接口数据进行微调即可。并且通过接口管理平台，开发人员可以更便捷地管理项目所有接口数据。</p>
<p>这里本文将主要认识学习一下目前国内开源较火的接口管理平台 YApi，看如何使用它帮助我们提高开发效率和便捷对接口的管理。</p>
<blockquote>
<p>本文不会描述 YApi 的安装部署过程，想要详细了解如何部署YApi可以参见文末提供的参考链接：<a href="https://hellosean1025.github.io/yapi/devops/index.html">YApi 安装部署</a>，<a href="https://www.jianshu.com/p/a97d2efb23c5">使用 Docker 构建 Yapi</a></p>
</blockquote>
<h2 id="yapi-介绍">YApi 介绍</h2>
<p>YApi 是一个可本地部署的、打通前后端及QA的、可视化的接口管理平台，以开发、产品、测试人员提供更优雅的接口管理服务为目标，该项目由去哪儿网大前端技术团队开源的，托管在 <a href="https://github.com/YMFE/yapi">Github</a> 上，已经 9000 多星。</p>
<p>YApi 作为 API 管理平台主要提供三大块功能：</p>
<ul>
<li>项目管理：提供基本的项目分组，项目管理，接口管理功能，成员权限管理</li>
<li>接口管理：提供友好的接口文档，支持多人协作接口编辑功能，以及类 Postman 测试工具便于高效调试接口</li>
<li>Mock 服务：基于<a href="http://mockjs.com/">Mock.js</a>，通过随机数据生成，模拟各种接口数据，充分发挥前后端分离的优势。</li>
</ul>
<blockquote>
<p><strong>什么是Mock</strong>.<strong>js</strong></p>
<p><strong>Mock</strong>.<strong>js是</strong>一个模拟数据生成器，帮助前端开发和原型与后端进度分离，减少一些单调，特别<strong>是</strong>在编写自动化测试时。</p>
<p>--- <a href="https://juejin.im/post/58f9eec0a22b9d00658ee4b7">mock.js那点事(上)</a></p>
</blockquote>
<p>当然 YApi 还有很多强大的功能，比如自动化测试，插件机制，二次开发等等。</p>
<p>下图是YApi 官方提供了使用 YApi 的工作流程，从这里可以简单了解下如何在日常开发中使用 YApi。</p>
<figure data-type="image" tabindex="2"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4ltwicwalj30fr05mmxc.jpg" alt=""></figure>
<h2 id="第一个-yapi">第一个 YApi</h2>
<h3 id="登录注册">登录注册</h3>
<p>使用 YApi 前，必须要先有登录账号，所以一开始需要在所搭建的 YApi 网站上注册一个账号,注册成功就可以用用户名或者邮箱进行登录。</p>
<figure data-type="image" tabindex="3"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4lui9szzej30hs0h63zi.jpg" alt=""></figure>
<p>注册成功后就会自动登录进入 YApi 首页，后面再次使用就可以直接用账号登录了。</p>
<p>需要注意的是作为新注册的用户，没有任何分组与项目的权限，只能对“公开项目” 的接口进行搜索、浏览 ，此时需要联系平台管理员将你加入对应项目。</p>
<p>下图为一个正常账户登录 YApi 首页的基本内容：</p>
<figure data-type="image" tabindex="4"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4lvcdoqchj30z30iwmz9.jpg" alt=""></figure>
<ol>
<li>
<p>首页头部展示了当前所在的位置、搜索框、新建项目、查看文档和用户信息。</p>
</li>
<li>
<p>首页左侧展示分组信息，“分组”是“项目”的集合，只有超级管理员可以管理分组。</p>
</li>
<li>
<p>首页右侧是分组下的项目和成员列表，点击左侧的某个分组，右侧会出现该分组下的项目和成员信息。</p>
</li>
<li>
<p>点击项目右上角的星星即可关注项目，关注的项目可以在“我的关注”页面查看。</p>
</li>
<li>
<p>点击头像进入“个人中心”，允许查看和修改个人信息。</p>
</li>
</ol>
<h3 id="项目接口">项目接口</h3>
<p>首先在项目列表选择一个项目进入(如果没有可用的项目，<strong>一种方式是找管理员分配项目权限</strong>，一种是在左上角点击 <strong>&quot;添加项目&quot;</strong> 新建一个项目），进入项目后可大致看到如下内容：</p>
<figure data-type="image" tabindex="5"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4lvmhjuoxj32ds0gu76z.jpg" alt="image-20190702224455234"></figure>
<ol>
<li>接口列表，展示该项目的所有接口名称，并且按照文件夹分类，默认都在公共分类下，也可以自定义添加分类。</li>
<li>测试集合，用于保存接口运行正常的数据信息和接口状态，便于后续直接使用测试集合中的接口测试。</li>
<li>添加接口，为项目添加接口，默认在公共分类下，需要指定接口名，请求方式和接口路径，保存后自动添加到接口列表下。</li>
<li>用于接口数据的导入导出，便于接口数据的迁移归档。</li>
<li>对项目信息的基本设置，如环境地址，接口路径，Mock 设置等。</li>
</ol>
<p>现在我们再来看下一个简单接口的页面展示内容：</p>
<figure data-type="image" tabindex="6"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4lwy0q71qj31ot0u0qbg.jpg" alt="image-20190702233037382"></figure>
<p>接口信息框内有四个面板可以切换，分别为预览，编辑，运行和高级 Mock，我们在<strong>编辑</strong>面板里可以通过接口的请求方式，请求数据，响应数据，接口描述等信息进行编辑，保存后都会在<strong>预览</strong>面板内清晰展示出来，当需要进行接口测试时就需要在<strong>运行</strong>面板里操作，里面的操作方式跟 Postman 很相似，相信使用过 Postman 的小伙伴应该能很快上手。</p>
<blockquote>
<p>注意：使用接口测试服务时，如果是 Chrome 浏览器 ，需安装测试增强插件,官方也提供了下载地址和安装教程。</p>
</blockquote>
<p>这里有一个小技巧可以分享下：每次进入接口的运行面板，上次使用请求参数都会被情况，每次都需要重新填写，如果请求接口参数一多就十分繁琐；这里我们可以把测试过的接口通过<strong>保存</strong>按钮加入到测试集合中，后面可以直接在测试集合中找到所记录的接口和有效的请求参数，并且能直接使用。</p>
<figure data-type="image" tabindex="7"><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4ni0ohvx0j320i0u0grq.jpg" alt="image-20190704082517792"></figure>
<p>高级Mock 一栏则是对接口模拟数据的设置，具体用法在后面会详细介绍。</p>
<p>到这里，YApi 的简单使用介绍完毕，使用 YApi 进行基本的接口测试和维护应该问题不大了，后续介绍 YApi 的更高级用法和最佳实践。</p>
<h2 id="mock-接口">Mock 接口</h2>
<p>本节主要描述如何通过 YApi 的 Mock 服务模拟接口的数据。</p>
<p>首先在接口面板里选择<strong>高级Mock</strong>一栏，选择添加期望来定义所实现模拟的条件和数据。</p>
<figure data-type="image" tabindex="8"><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4q58uwh2nj31mk0jy76i.jpg" alt="image-20190706151957646"></figure>
<p>添加期望时分为两部分，一块是填关于期望的基本信息，如名称，白名单IP，匹配的参数等，另外一块就是期望模拟的响应数据，如响应头信息，响应体数据，甚至响应时间也可以设置。</p>
<p>在这里设置响应体数据时，除了使用常规的固定假数据返回，我们可以使用 Mock.js 支持的语法，让假数据随机生成，例如下方的示例模拟一个简单的响应数据： <code>code</code>  为 200 或者 400，<code>message</code> 为重复出现 1~10次的测试两次。</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4q5frzj1mj31440n0jsr.jpg" alt="image-20190706152640885">保存之后，我们对接口的 Mock 地址*（预览面板中 Mock 地址链接）*进行多次请求就随机获得以下的请求数据：</p>
<pre><code class="language-json">{
&quot;code&quot;: 200,
&quot;message&quot;: &quot;测试测试测试&quot;,
&quot;data&quot;: {}
}

{
&quot;code&quot;: 400,
&quot;message&quot;: &quot;测试测试测试测试测试测试&quot;,
&quot;data&quot;: {}
}
</code></pre>
<p>当然除了这样方式定义模拟数据的生成，还有许多丰富的形式，具体的数据定义语法可以参见 Mock.js 提供的官方示例：<a href="http://mockjs.com/examples.html">http://mockjs.com/examples.html</a></p>
<h2 id="最佳实践">最佳实践</h2>
<h3 id="接口分级">接口分级</h3>
<p>YApi 以项目为单位进行接口的管理，基于此还提供的分类的功能，新生成的接口都有默认的分类为公共分类。</p>
<p>为了能更清晰，更直观有效地管理接口，我们可以从项目的业务角度出发，在 YApi 中将业务转换为接口分类，每个业务分类下管理各自相关的接口，而一些公共接口统一在公共分类中管理，比如下图所示，将订单业务和支付业务分别生成各自的接口分类，在该分类下都是跟自身业务紧密相关的接口。</p>
<figure data-type="image" tabindex="9"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4q7fnyv61j30k40u6ta8.jpg" alt="image-20190706163548920"></figure>
<h3 id="环境配置">环境配置</h3>
<p>当日常开发中一个程序都会有不同环境要求，接口请求的地址也不同，为了便于多环境接口的切换，我们可以在项目设置的<code>环境配置</code> 一项添加该项目下接口的多个环境，并且这里增加了全局 <code>header</code>，项目中设置全局 <code>header</code> 值。</p>
<figure data-type="image" tabindex="10"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4q62cpsssj31fm0u041f.jpg" alt="image-20190706154822768"></figure>
<p>除此之外，用户可以在每个环境配置项中定义 <code>global</code> 全局变量的名称和值, 接口运行或者测试集合里面可以通过 <code>{{ global.Name }}</code> 来访问当前环境变量下定义的全局变量。</p>
<p>设置保存之后，我们就可以在该项目下任一接口的运行面板里切换环境地址，如下<img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4q677juu6j314w0jcada.jpg" alt="image-20190706155307573"></p>
<h3 id="请求配置">请求配置</h3>
<p>YApi 支持 <code>pre-script</code>, 就是通过自定义 js 脚本方式改变请求的参数和返回的 Response 数据，而这个功能可以满足当我们请求和响应的数据都是通过加密处理的使用场景。</p>
<p>请求配置的位置同样在项目设置里，针对项目的所有接口生效，对外提供公共变量 <code>context</code> 对象包含的请求和响应的所有数据 。</p>
<figure data-type="image" tabindex="11"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4q730zf86j30u011ljvq.jpg" alt="image-20190706162341811"></figure>
<p>如果我们需要在一组接口的 URL 上增加一个公共的 <code>token</code> 参数，可以在 Pre-request Script 里写如下脚本：</p>
<pre><code class="language-javascript">context.query.token = context.utils.md5(context.pathname + 'salt');
</code></pre>
<p>而如果我们需要修改响应数据中某个值进行修改，可以填写如下 Pre-response Script 里写如下脚本：</p>
<pre><code class="language-javascript">context.responseData.key = newValue;
</code></pre>
<p>另外，全局变量 <code>context</code> 还提供的工具函数，让我们使用：</p>
<pre><code class="language-javascript">context.utils = {
  _         //underscore 函数,详细 API 查看官网 http://underscorejs.org/
  CryptoJS  // crypto-js（v1.3.21+新增）, 详细用法看 https://github.com/brix/crypto-js
  base64    //转换字符串为 base64 编码
  md5       //转换字符串为 md5 编码
  sha1      //转换字符串为 sha1 编码
  sha224    //转换字符串为 sha224 编码
  sha256    //转换字符串为 sha256 编码
  sha384    //转换字符串为 sha384 编码
  sha512    //转换字符串为 sha512 编码
  unbase64  //转换 base64 编码为字符串  
  axios     // axios 库，可用于 api 请求，官网 https://github.com/axios/axios
}
</code></pre>
<p>结合工具函数，我们就可以进行接口请求时和响应时的加密处理，例如我们需要对响应体中 <code>data</code> 数据进行 Base64 加密，可以定义如下脚本：</p>
<pre><code class="language-javascript">context.responseData.data = context.utils.base64(context.responseData.data);
</code></pre>
<h3 id="数据导入导出">数据导入导出</h3>
<p>在数据管理上，YApi 提供了简单而有效的方案来支持数据的导入和导出。</p>
<p>YApi 支持快速导入其他格式的接口数据，以方便快速添加接口。YApi 目前支持 Postman, Swagger, JSON 数据导入等，方便我们进行接口数据迁移。</p>
<p>而当我们需要把接口分享给非项目组内的人时，我们可以使用数据导出功能，以 HTML，Markdown 或者 JSON 的格式导出项目接口文档数据，只需要将文档文件给到他人就行了。</p>
<figure data-type="image" tabindex="12"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4q914qmuij318w0u0djh.jpg" alt="image-20190706173104594"></figure>
<h2 id="结语">结语</h2>
<p>本文主要记录了开源接口管理平台- YApi的基本介绍和使用。面对多人多项目的团队开发，有个统一的管理平台来进行接口管理和维护，还是很有必要的，也是很基础的，对项目的开发效率提高也有很大帮助，如果你有正在使用 YApi 有更好的使用姿势或者遇到什么坑，更或者在使用过其他的接口管理平台框架，也欢迎留言交流讨论😃。</p>
<figure data-type="image" tabindex="13"><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g4qez0uahnj30p00dwwm4.jpg" alt="公众号扫码"></figure>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>YApi 安装部署：https://hellosean1025.github.io/yapi/devops/index.html</p>
</li>
<li>
<p>使用 Docker 构建 Yapi： https://www.jianshu.com/p/a97d2efb23c5</p>
</li>
<li>
<p>YApi 官方教程：https://hellosean1025.github.io/yapi/documents/index.html</p>
</li>
<li>
<p>Github 地址：https://github.com/YMFE/yapi</p>
</li>
<li>
<p>mock.js那点事(上)：https://juejin.im/post/58f9eec0a22b9d00658ee4b7</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[掌握设计模式之适配器模式]]></title>
        <id>https://wrcj12138aaa.github.io//post/20190630-掌握设计模式之适配器模式</id>
        <link href="https://wrcj12138aaa.github.io//post/20190630-掌握设计模式之适配器模式">
        </link>
        <updated>2019-06-30T14:05:20.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jipii0vyj30p00dw45x.jpg" alt="公众号扫码"></figure>
<h2 id="前言">前言</h2>
<p>由于所在行业的需求，需要跟许多第三方系统进行接口对接，并且虽然每个系统大同小异，但每次对接开发都采用重写一套，独立维护，对接时间久了就开始考虑有什么方式能将这么多的三方系统接口接入现有系统时统一规范化，按照固定模式接入，带着这个疑惑我开始四处寻求答案。在近期参加的《Head First Design Patterns》技术读书营中，以学习设计模式，提高编码设计能力为目的我，看到适配器模式之后，明白它就是解除我疑惑的那个答案，紧接深入学习研究，于是就有了这篇文章。那么这是个怎样的模式，以及如何使用的呢，接下来就让我们学习下吧。</p>
<h2 id="正文">正文</h2>
<h3 id="什么是适配器模式">什么是适配器模式</h3>
<p>首先我们来看下维基百科的定义：</p>
<blockquote>
<p>In software engineering, the adapter pattern is a software design pattern that allows the interface of an existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source code.</p>
</blockquote>
<p>大概意思就是将一个已存在类的接口转换为另一个接口去使用，使得在不需要修改原有代码的情况下使得原本接口不兼容的类,能与其他类正常工作。这里强调了不改动原有系统的源代码的情况下，对不兼容的接口进行适配，其实就是一层转换，转换成已有系统所采用的接口方式。</p>
<p>除此之外，再来看下 Gang of Four 的《设计模式》中的定义：</p>
<blockquote>
<p>“Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.”</p>
</blockquote>
<p>这里主要还是描述的适配器的行为：将类的接口转为客户端所期待的接口，也就是可直接使用的，最终消除的就是接口之间的不兼容性。</p>
<p>大概了解适配器模式的定义,我们再来看个生活的例子，来更好理解下适配器模式：</p>
<p>自 iPhone7 开始，iPhone 已经取消了耳机插孔, 而这样一来，就无法直接使用苹果有线耳机了。那该怎么办呢，随即苹果推出耳机转接线，来协调无耳机插孔的 iPhone 和耳机之间连接,一端支持苹果正常的充电插口,另端支持苹果耳机插口, 用过转换保证即使无耳机插孔的 iPhone 能正常使用有线耳机，这就是通过特定方式转换来解决两个事物的兼容问题。</p>
<figure data-type="image" tabindex="2"><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4j5xm40ytj307i050q2q.jpg" alt="耳机转接线"></figure>
<h3 id="适配器模式结构">适配器模式结构</h3>
<p>清楚什么是适配器模式之后，我们再来了解下适配器模式的结构以及如何识别它。</p>
<p>首先我们认识下适配器模式中存在的主要角色，看下他们是如何在适配器模式扮演怎样的角色：</p>
<ul>
<li><strong>Target</strong> 目标类：要把其他类转换为我们期望接口的类。</li>
<li><strong>Adaptee</strong> 被适配者： 想要转换成目标角色的类.</li>
<li><strong>Adapter</strong> 适配者：需要要新建,并且要把 Adaptee 被适配者类转换为 Target 目标类,转换方式一般采用类继承或者对象组合的方式.</li>
<li><strong>Client</strong> 客户端类：通常为我们原有系统中与 Target 目标类交互的类。</li>
</ul>
<p>适配器模式通常有两种存在的形式：对象适配器和类适配器。差异主要就体现在模式结构上，接下来就看下这两种形式的 UML 图:</p>
<ul>
<li>
<p>对象适配器 UML 图<img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4j7hma8obj315u0f6gn4.jpg" alt="对象适配器"></p>
</li>
<li>
<p>类适配器 UML 图<img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4j7l1keg4j31860feabp.jpg" alt="类适配器"></p>
</li>
</ul>
<p>从上面两张图可以看出对象适配器与类适配器的区别在于适配器类与被适配者的关系，是采用组合的方式还是继承。所谓组合，就是拥有该类型的实例成员变量。</p>
<p>对象适配器可以适配某个类以及其任何子类，而类适配器只能适配特定的类，但它不需要重新实现被适配者类的所有方法，并且必要时可以覆写某些方法。</p>
<p>有了 UML 类这里我们看下适配器模式的通用代码实现：<img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4jiwkf9xdj30u01hvjul.jpg" alt="carbon"></p>
<p>所有角色类已经有了,就来看下客户端类如何使用适配器类：<img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jixkyljbj311s0symzj.jpg" alt="carbon"></p>
<p>有了实现的代码，我们再来试着画出对应时序图，来更清楚地认识类之前调用关系：<img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4j8fxxhm4j310s0lumyv.jpg" alt="image-20190630155053150"></p>
<p>在前文提到的 iPhone 与耳机之间的适配问题例子中, 耳机转接线无疑就是 Adapter 角色, iPhone 的充电接口为 Target 角色, 耳机接口为 Adaptee 角色。</p>
<h3 id="适配器模式实现案例">适配器模式实现案例</h3>
<p>现在我们再用代码来实现另一个适配器案例：假设我们有一台笔记本和一个显示器,想要笔记本屏幕投影到显示器上,但是笔记本只支持 HDMI 接口输出,显示器只支持 VGA 接口输入, 想要它们之间正常工作,就需要用接口适配器来进行转换.</p>
<p>首先我们看下目标类 HDMI 代码以及要转换为目标类的 Adaptee 类：<img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4jiza9ajwj311s0git9u.jpg" alt="carbon"></p>
<p>那么想要将 HDMI 与 VGA 连接起来的 Adapter 类 VGA2HDMIAdapter 又是什么样的呢,请看下方代码：<img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4jj06xcfkj311s0puwg5.jpg" alt="carbon"></p>
<p>最后看下客户端类中的使用：<img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4jj0ljyhjj30wj0u0jtb.jpg" alt="carbon"></p>
<p>这样一个简单的适配器模式案例就完成了,虽然代码简单,但类之间的组合使用很好地说明了适配器模式的结构。HDMI 接口作为目标对象，而 VGA 接口为被适配对象，为了能在 Laptop 对象上工作，通过了适配器对象的转换 VGA2HDMIAdapter 。</p>
<h3 id="常见的适配器用法">常见的适配器用法</h3>
<p>适配器模式也算是十分常用的设计模式，我们可以在很多框架的源码里见到，在 JDK 中适配器也有很多的应用，这里我们就进行简单介绍：</p>
<h4 id="jdk-inputstreamreader">JDK-InputStreamReader</h4>
<figure data-type="image" tabindex="3"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4jj1elapjj31a208qabj.jpg" alt="carbon"></figure>
<p>上面代码：<code>System.in</code> 实际是类型为 InputStream，而由于 BufferedReader 与 InputStream 不能一起工作，于是引入 BufferedReader 类，作为适配器类，将 InputStreamReader 类的接口转成 BufferedReader 类可用的接口。</p>
<h4 id="jdk-javautilcollectionsenumeration">JDK-java.util.Collections#enumeration</h4>
<figure data-type="image" tabindex="4"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jj1ui5j9j313c0mqmz1.jpg" alt="carbon"></figure>
<p>在这里，Enumeration 作为被适配者类，Iterator 为目标类，为了让 Iterator 能提供遍历元素的功能，提供了 EnumerationIterator 作为适配器类。</p>
<h4 id="springmvc-requestmappinghandleradapter">SpringMVC-RequestMappingHandlerAdapter</h4>
<p>仅从命名方式上就可以看到 RequestMappingHandlerAdapter 属于适配器模式中适配器角色，用于处理带有 <strong>@RequestMapping</strong> 注解方法，当 Spring MVC 接受请求时会根据 URL 匹配对应的 RequestMappingHandlerAdapter，调用它的 <code>invokeHandlerMethod()</code> 方法。</p>
<h3 id="适配器模式应用场景">适配器模式应用场景</h3>
<p>了解那么多关于适配器的使用，我们再来总结下使用适配器模式的常见场景：</p>
<ul>
<li>当已存在类的接口无法满足的所需要接口的功能，即接口之间不兼容。</li>
<li>当需要创建一个可重用的类,而该类能与多个不同类一起工作。</li>
<li>大多数使用第三方库的应用程序可以使用适配器作为应用程序和第三方库之间的一个中间层，使应用程序与三方库解耦。</li>
</ul>
<h2 id="结语">结语</h2>
<p>本文学习总结了适配器模式的定义和用法，以及具体使用场景。后续我还有继续学习总结其他设计模式，欢迎感兴趣的小伙伴可以关注我的微信公众号，一起学习探讨，技术文章每周一更 😁。</p>
<figure data-type="image" tabindex="5"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jj3zrg9uj3076076weq.jpg" alt="微信公众号"></figure>
<h2 id="参考">参考</h2>
<ul>
<li>设计模式[1]-什么是四人帮(Gang of Four)：https://blog.csdn.net/gladyoucame/article/details/84535764</li>
<li>Patterns-Adapter：https://java-design-patterns.com/patterns/adapter/</li>
<li>《设计模式之禅》：https://book.douban.com/subject/4260618/</li>
<li>Adapter Design Pattern in Java：https://howtodoinjava.com/design-patterns/structural/adapter-design-pattern-in-java/</li>
<li>《Head First Design Patterns》：https://book.douban.com/subject/1400656/</li>
</ul>
<h2 id="推荐阅读">推荐阅读</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/2qkNz4VPgnixXjaVYUkvvQ">Java 之 Lombok 必知必会</a></li>
<li><a href="https://mp.weixin.qq.com/s/HzYwhCUJX91mfSvS-_aeMg">Java 开发看的 Scala 入门</a></li>
<li><a href="https://mp.weixin.qq.com/s/vS36glyNoD26GL6cbNs5Qw">Java 微服务新生代之 Nacos</a></li>
<li><a href="https://mp.weixin.qq.com/s/GCjXZybnweHNKi0dVpR46A">Java 微服务新生代 Nacos 之配置管理</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java微服务新生代Nacos之配置管理]]></title>
        <id>https://wrcj12138aaa.github.io//post/20190623-Java微服务新生代Nacos之配置管理</id>
        <link href="https://wrcj12138aaa.github.io//post/20190623-Java微服务新生代Nacos之配置管理">
        </link>
        <updated>2019-06-23T02:06:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在上文  <a href="https://mp.weixin.qq.com/s/vS36glyNoD26GL6cbNs5Qw">Java微服务新生代之Nacos</a> 已经介绍了微服务框架 Nacos 以及它在服务注册与发现的功能，本文将主要介绍它的另一强大功能：配置管理，学习利用 Nacos 如何实现通过统一的管理界面，集中化实现分布式服务的配置维护和实时更新。</p>
<p>本文主要内容涉及如下：</p>
<ul>
<li>Nacos配置管理概念介绍</li>
<li>如何 Nacos 管理配置</li>
<li>Nacos 多环境配置管理</li>
</ul>
<h2 id="介绍nacos配置管理">介绍Nacos配置管理</h2>
<p>Nacos 提供了动态配置服务，能让我们可以实时进行服务应用的配置变更，让配置管理变得更加高效和快捷。它基于 key/value 方式存储应用配置和其他元数据信息，为分布式系统中的外部化配置提供服务器端和客户端支持。</p>
<p>首先了解下 Nacos 在配置管理模块上的几个重要概念，能帮助我们更好的理解和正确的使用 Nacos 进行配置管理。</p>
<ul>
<li>
<p><strong>命名空间（Namespace）</strong></p>
<p>用于进行租户粒度的配置隔离，可用于对不同环境配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p>
</li>
<li>
<p><strong>配置项 (Configuration Item)</strong></p>
<p>一个具体的可配置的参数与其值，通常以 param-key=param-value 的形式存在。例如我们常配置系统的日志输出级别（logLevel=INFO|WARN|ERROR） 就是一个配置项。</p>
</li>
</ul>
<ul>
<li>
<p><strong>配置集 (Configuration Set)</strong></p>
<p>一组相关或者不相关的配置项的集合。一个配置文件通常就是一个配置集，它可能包含了数据源、线程池、日志级别等配置项。</p>
</li>
<li>
<p><strong>配置集 ID（Data ID）</strong></p>
<p>某个配置集的标识 ID，用于组织划分系统的配置集。一个系统或者应用可以包含多个配置集。官方推荐采用类 Java 包（如 com.taobao.tc.refund.log.level）的命名规则定义 Data ID 来保证全局唯一性。</p>
</li>
<li>
<p><strong>配置分组（Group）</strong></p>
<p>对配置集进行分组，用于区分 Data ID 相同的配置集。默认采用 DEFAULT_GROUP 。配置分组的常见场景：不同的应用或组件使用了相同的配置类型，如 database_url 配置和 消息队列 Topic 配置等。</p>
</li>
</ul>
<h2 id="启动nacos配置管理">启动Nacos配置管理</h2>
<p>要使用 Nacos 进行配置管理，首先需要启动 Nacos 服务端，然后客户端接入，关于 Nacos 的服务端启动具体操作可以参见 <a href="https://wrcj12138aaa.github.io/2019/06/16/Java%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B9%8BNacos/">Java微服务新生代之Nacos</a> 。</p>
<p>启动了 Nacos 服务端，首先我们在 Nacos 控制台上的配置管理里新建一个最简单的配置，如图：</p>
<figure data-type="image" tabindex="1"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4b2e8pm1cj317i0qitbp.jpg" alt="image-20190623141751675"></figure>
<p>保存成功后能列表里看下创建的配置记录如下：</p>
<figure data-type="image" tabindex="2"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4b2g91tnoj32dq0fs78a.jpg" alt="image-20190623141953948"></figure>
<p>每个配置集的操作栏都提供了配置的查看修改和清除功能，还有额外的示例代码查看，来引导我们如何在客户端使用 Nacos 读取该配置集，目前只支持 Java，Spring Boot，Spring Cloud，其他语言的版本还在完善语言。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4b2h79y7sj31040qoq6o.jpg" alt="image-20190623142049041">接下里看下Nacos 基于 Spring 技术栈的集成方式</p>
<h3 id="nacos-spring">Nacos Spring</h3>
<ol>
<li>
<p>首先给 Spring 程序添加依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;
    &lt;artifactId&gt;nacos-spring-context&lt;/artifactId&gt;
    &lt;version&gt;0.2.3-RC1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>最新版本可以在 maven 仓库 <a href="https://mvnrepository.com/artifact/com.alibaba.nacos/nacos-spring-context">mvnrepository.com</a> 中获取。</p>
</blockquote>
</li>
<li>
<p>添加 <code>@EnableNacosConfig</code> 注解启用 Nacos Spring 的配置管理服务。如下示例，我们使用了 <code>@NacosPropertySource</code> 注解加载了我们先前创建的配置集，并且指定为自动刷新配置。<br>
<img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4bf7vf21lj30n1053aap.jpg" alt=""></p>
</li>
<li>
<p>通过 Nacos 的 <code>@NacosValue</code> 注解将配置项与属性进行绑定。</p>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4bfa8ykwhj311s0l6gni.jpg" alt=""></figure>
<ol start="4">
<li>
<p>启动程序后，打开 <code>http://localhost:8080/config/hello</code> 获取返回结果<code>hello,test</code>，内容如下就表示读取配置成功。</p>
<figure data-type="image" tabindex="4"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4bfacjs3sj311s042aa0.jpg" alt=""></figure>
</li>
<li>
<p>读取成功后我们再尝试修改这个配置项验证下 Nacos 的配置信息的动态刷新特性。修改有两种方式，一种在 Nacos 控制台上手动修改，另一种在命令行使用提供的 API 直接进行修改：</p>
<pre><code class="language-shell">curl -X POST &quot;http://127.0.0.1:8848/nacos/v1.0.1/cs/configs?dataId=com.one.learn.nacos.config&amp;group=DEFAULT_GROUP&amp;content=message=nacos-spring&quot;
</code></pre>
</li>
<li>
<p>再次访问 <code>http://localhost:8080/config/hello</code>，此时返回内容为<code>hello,nacos-spring</code>，返回信息变化说明程序中的<code>message</code>值已经被动态更新了。</p>
<figure data-type="image" tabindex="5"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4bfc3jl7cj311s04274b.jpg" alt=""></figure>
</li>
</ol>
<h3 id="nacos-spring-boot">Nacos Spring Boot</h3>
<ol>
<li>
<p>添加配置动态变更的依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;
    &lt;artifactId&gt;nacos-config-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;0.2.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p><strong>注意</strong>： 这里的版本 <a href="https://mvnrepository.com/artifact/com.alibaba.boot/nacos-config-spring-boot-starter">0.2.x.RELEASE</a> 对应的是 Spring Boot 2.x 版本，版本 <a href="https://mvnrepository.com/artifact/com.alibaba.boot/nacos-config-spring-boot-starter">0.1.x.RELEASE</a> 对应的是 Spring Boot 1.x 版本。</p>
</blockquote>
</li>
<li>
<p>在 <code>application.properties</code> 中配置 Nacos Server 的地址：</p>
</li>
</ol>
<pre><code class="language-properties">nacos.config.server-addr=127.0.0.1:8848
</code></pre>
<ol start="3">
<li>
<p>使用 <code>@NacosPropertySource</code> 加载 <code>dataId</code> 为 <code>com.one.learn.nacos.config</code> 的配置源，并开启自动更新：</p>
<figure data-type="image" tabindex="6"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4bfcesqw3j31800de0ui.jpg" alt=""></figure>
</li>
<li>
<p>通过 Nacos 的 <code>@NacosValue</code> 注解设置属性值,与集成 Spring 的步骤内容一样。</p>
</li>
<li>
<p>启动引导类，打开 <code>http://localhost:8080/config/hello</code> 获取返回结果<code>hello,nacos</code>, 说明程序中的配置已经读取成功。</p>
</li>
</ol>
<h3 id="nacos-spring-cloud">Nacos Spring Cloud</h3>
<p>如果使用 Spring Cloud 程序，Nacos 提供了依赖库  <code>spring-cloud-starter-alibaba-nacos-config</code> 实现配置的动态变更。</p>
<ol>
<li>
<p>添加依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
    &lt;version&gt;0.9.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p><strong>注意</strong>：版本 <a href="https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-alibaba-nacos-config">0.2.x.RELEASE</a> 对应的是 Spring Boot 2.x 版本，版本 <a href="https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-alibaba-nacos-config">0.1.x.RELEASE</a> 对应的是 Spring Boot 1.x 版本。</p>
</blockquote>
</li>
<li>
<p>在 <code>bootstrap.properties</code> 中配置 Nacos server 的地址和应用名如下，在 Nacos Spring Cloud 中，<code>dataId</code> 默认为 <code>spring.application.name</code> 加上 <code>properties</code> 文件后缀，所以，为了能正确读取配置，我们需要将 Nacos 上配置集 ID 为 <code>com.one.learn.nacos.config</code> 调整为 <code>com.one.learn.nacos.config.properties</code></p>
<pre><code class="language-properties">spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.application.name=com.one.learn.nacos.config
</code></pre>
<p>这里使用 bootstrap.properties 作为配置 Nacos 地方，是因为 Spring Boot 配置文件的加载顺序，依次为 bootstrap.properties -&gt; bootstrap.yml -&gt; application.properties -&gt; application.yml ，在 <code>application</code> 层级上配置 Nacos 时无法生效。</p>
<blockquote>
<p>注意：当使用域名的方式来访问 Nacos 时，<code>spring.cloud.nacos.config.server-addr</code> 配置的方式必须为 <code>域名:port</code>。 即使使用域名，端口不能省略。例如 Nacos 的域名为 abc.com.nacos，监听的端口为 80，则 <code>spring.cloud.nacos.config.server-addr=abc.com.nacos:80</code>。</p>
</blockquote>
</li>
<li>
<p>通过 Spring Cloud 原生注解 <code>@RefreshScope</code> 实现配置自动更新：<img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4bfe64ebpj311s0mqtbk.jpg" alt=""></p>
</li>
<li>
<p>运行程序，访问  <code>http://localhost:8080/config/hello</code>  ，返回内容为  <code>hello,nacos</code> ，则表示配置读取成功。</p>
</li>
<li>
<p>在 Nacos 控制台修改配置项 <code>message=Nacos Spring Cloud</code>，再次访问   <code>http://localhost:8080/config/hello</code>  , 返回内容为 <code>hello,Nacos Spring Cloud</code>,说明程序中的<code>message</code>值已经被动态更新了。</p>
</li>
</ol>
<h2 id="nacos-多环境配置管理">Nacos 多环境配置管理</h2>
<p>上面实现了Nacos基本的配置读取和更新后，接下来我们看下 Nacos 如何进行多环境配置的管理，需要注意的是此特性仅针对于 Spring Cloud 应用。</p>
<p>假设我们程序有两个环境：测试，生产环境需要管理配置，在 Spring Boot 程序中，默认的配置文件为 application.properties，传统的方式是，利用 Spring Profile 特性，在项目里存放多个环境对应的配置文件，文件格式为 <code>application-${env}-properties</code>，并且需要用 <code>spring.profile.active</code> 指定启动时应用哪个环境的配置。</p>
<p>Nacos Config 主要通过 dataId 和 group 来唯一确定一条配置，在 Nacos Spring Cloud 中，<code>dataId</code> 的完整格式如下：</p>
<pre><code class="language-properties">${prefix}-${spring.profile.active}.${file-extension}
</code></pre>
<ul>
<li>
<p><code>prefix</code> 默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</p>
</li>
<li>
<p><code>spring.profile.active</code> 即为当前环境对应的 profile，详情可以参考 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html#boot-features-profiles">Spring Boot文档</a>。</p>
<blockquote>
<p><strong>注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 {prefix}.{file-extension}</strong></p>
</blockquote>
</li>
<li>
<p><code>file-exetension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置。目前只支持 <code>properties</code> 和 <code>yaml</code> 类型。</p>
</li>
</ul>
<p>group 默认为 <code>DEFAULT_GROUP</code>，可以通过 <code>spring.cloud.nacos.config.group</code> 自定义指定名称。</p>
<ol>
<li>基于上面的配置规则描述，我们可以先在 Nacos 控制台上新建两个不同环境的配置集，如下</li>
</ol>
<figure data-type="image" tabindex="7"><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4b7g51e5bj317g0gwwgp.jpg" alt="image-20190623171248544"></figure>
<p>都存放两个配置项,以 <code>property</code> 文件格式存储。</p>
<pre><code class="language-properties">#nacos-config-prod.properties
server.port=8091
message=nacos-config-prod

#nacos-config-test.properties
server.port=8081
message=nacos-config-test
</code></pre>
<ol start="2">
<li>然后在程序的主配置文件 <code>application.properties</code> 中配置如下：</li>
</ol>
<pre><code class="language-properties">spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.application.name=nacos-config
spring.cloud.nacos.config.file-extension=properties
spring.profile.active=test
</code></pre>
<ol start="3">
<li>
<p>编写测试控制器类 ConfigController，将配置项与属性值进行绑定。<img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4bfg1585mj311s0mqju8.jpg" alt=""></p>
</li>
<li>
<p>启动程序，可以看到如下数据结果，说明测试环境下端口配置已经生效。<img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4bfgnjte1j31kw0i27a8.jpg" alt=""></p>
<p>再通过浏览器访问 <code>http://localhost:8081/config/hello</code>，返回 <code>hello，nacos-config-test</code> 。</p>
</li>
<li>
<p>修改配置文件  <code>application.properties</code>  的 <code>spring.profile.active</code> ，重新启动程序并访问  <code>http://localhost:8091/config/hello</code></p>
<pre><code class="language-properties">spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.application.name=nacos-config
spring.cloud.nacos.config.file-extension=properties
spring.profile.active=prod
</code></pre>
<p>能获取到返回结果 <code>hello，nacos-config-prod</code> , 也说明程序另一个环境的配置切换成功。</p>
</li>
</ol>
<h3 id="配置监听">配置监听</h3>
<p>除了主动检验配置生效之外，我们可以通过添加监听器的方式来监听配置的变化，实现很简单，使用 <code>@NacosConfigListener</code> 即可，一旦指定的配置集 ID 对应配置发生了变化，监听器就会受到回调，将所有的配置信息以字符串形式返回。<br>
<img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4bfhl0ffzj311s08q3zr.jpg" alt=""></p>
<blockquote>
<p>当存在多个配置项时，回调接收到的配置字符串中带有换行格式，需要自己处理。</p>
</blockquote>
<p>当然 <code>@NacosConfigListener</code> 也支持类型转换，比如转换为 Properties 对象<br>
<img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4bfi4bxx4j311s08q0u0.jpg" alt=""></p>
<h2 id="namespace-最佳实践">Namespace 最佳实践</h2>
<p>Nacos 里 Namespace 作为租户颗粒度细分而存在，主要为了解决多环境以及多租户数据(<strong>配置和服务</strong>)隔离的问题。</p>
<ul>
<li>
<p>如果只是一个租户(用户)，不同的 namespce 可以对应不同的环境，以此实现环境配置的隔离，效果就跟上节内容：Nacos 多环境配置管理 相似。</p>
<figure data-type="image" tabindex="8"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4b8gmnsd6j314k0jkwhb.jpg" alt="img"></figure>
</li>
<li>
<p>如果存在多个租户，为每个租户分配不同的 namespace，这样每个租户(用户)的配置数据以及注册的服务数据都会归属到自己的 namespace 下，就可以实现多租户配置数据隔离作用。</p>
<figure data-type="image" tabindex="9"><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4b8jts5gxj314a0je778.jpg" alt="img"></figure>
<blockquote>
<p>注意：Nacos 目前还没实现账号权限的分配和隔离，无法让各租户自己管理自己的配置，这一块功能仍在规划中。</p>
</blockquote>
</li>
</ul>
<p>简单介绍之后，再来看下 namespace 相关的最佳实践：</p>
<ul>
<li>如何来获取 namespace 的值。</li>
<li>namespace 参数初始化方式。</li>
</ul>
<h3 id="创建命名空间">创建命名空间</h3>
<p>在 nacos 的控制台左边功能侧看到有一个 <strong>命名空间</strong> 的功能，点击就可以看到 <strong>新建命名空间</strong> 的按钮，那么这个时候就可以创建自己的命名空间了。创建成功之后，会生成一个<strong>命名空间ID</strong>，主要是用来避免<strong>命名空间名称</strong>有可能会出现重名的情况。因此当您在应用中需要配置指定的 namespace 时，<strong>填入的是命名空间ID</strong>。</p>
<figure data-type="image" tabindex="10"><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4b8w32xgxj319e0r8mz1.jpg" alt="image-20190623180238812"></figure>
<h3 id="关联命令空间">关联命令空间</h3>
<p>在没有明确指定 <code>${spring.cloud.nacos.config.namespace}</code> 配置的情况下， 默认使用的是 Nacos 上 Public 这个namespae。如果需要使用自定义的命名空间，可以通过以下配置来实现：</p>
<pre><code class="language-properties">spring.cloud.nacos.config.namespace=b3404bc0-d7dc-4855-b519-570ed34b62d7
</code></pre>
<blockquote>
<p>该配置必须放在 bootstrap.properties 文件中。此外 <code>spring.cloud.nacos.config.namespace</code> 的值是 namespace 对应的 id。</p>
</blockquote>
<h2 id="结语">结语</h2>
<p>到这里，到这里关于 Nacos 管理配置的学习就告一段落，当然在配置管理上还有更多的用法，Nacos 官方文档描述的也很详细，大家也可以多在官网上查阅。后续我将继续深入研究其他 Spring Cloud Alibaba 微服务生态的组件，欢迎感兴趣的小伙伴可以关注我的微信公众号，每周一更。</p>
<figure data-type="image" tabindex="11"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4belazf68j30p00dw766.jpg" alt="公众号"></figure>
<h2 id="代码示例">代码示例</h2>
<blockquote>
<p>示例项目：<strong>nacos-actions</strong>：https://github.com/wrcj12138aaa/nacos-actions</p>
<p>环境支持：</p>
<ul>
<li>JDK 8</li>
<li>Maven 3.6.0</li>
<li>SpringBoot 2.1.0.RELEASE</li>
<li>SpringCloud  Greenwich.RELEASE</li>
<li>SpringCloudAlibaba 0.9.0.RELEASE</li>
</ul>
</blockquote>
<h2 id="参考">参考</h2>
<ul>
<li>Java微服务新生代之Nacos：https://mp.weixin.qq.com/s/vS36glyNoD26GL6cbNs5Qw</li>
<li>Nacos 概念: https://nacos.io/zh-cn/docs/concepts.html</li>
<li>Spring Cloud Alibaba基础教程：Nacos配置的多环境管理：http://blog.didispace.com/spring-cloud-alibaba-nacos-config-2/</li>
<li>Nacos 官方文档：https://nacos.io/zh-cn/docs/what-is-nacos.html</li>
</ul>
]]></content>
    </entry>
</feed>