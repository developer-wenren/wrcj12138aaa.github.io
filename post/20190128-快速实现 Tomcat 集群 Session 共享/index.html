<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>快速实现 Tomcat 集群 Session 共享 | 闻人的技术博客</title>
<meta name="description" content="做一个终生学习的技术人">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://wrcj12138aaa.github.io//favicon.ico?v=1574522179527">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://wrcj12138aaa.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://wrcj12138aaa.github.io/">
        <img src="https://wrcj12138aaa.github.io//images/avatar.png?v=1574522179527" class="site-logo">
        <h1 class="site-title">闻人的技术博客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      做一个终生学习的技术人
    </div>
    <div class="site-footer">
       | <a class="rss" href="https://wrcj12138aaa.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">快速实现 Tomcat 集群 Session 共享</h2>
            <div class="post-date">2019-01-28</div>
            
            <div class="post-content">
              <h3 id="前言">前言</h3>
<p>在应对巨大的用户流量的互联网场景中, 搭建 Tomcat 集群是缓解 Web 服务器负载的解决方式中必不可少的,而随之带来的会话信息即 Session 不同步的问题也暴露出来: 用户刚登录后,再次操作却提示需要重新登录,严重影响着用户体验. 本文主要研究如何使用 Spring Session 框架来解决 Tomcat 集群会话共享问题.若有补充,欢迎斧正.</p>
<h3 id="正文">正文</h3>
<h5 id="环境准备">环境准备</h5>
<ul>
<li>3个 Tomcat 实例</li>
<li>Redis</li>
</ul>
<h5 id="项目结构">项目结构</h5>
<p>项目比较简单,除了启动类之外,就只有一个控制器类.<br>
<img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzljusmiqoj30c40a0q31.jpg" alt=""></p>
<h5 id="控制器实现">控制器实现</h5>
<p>UserController 主要有两个请求方法, 一个接受用户登录,另一个获取登录信息的;当调用 <code>login</code> 接口后将请求数据存在当前的 Session 中,然后在 Session 有效的期间内调用 <code>getUserInfo</code> 接口都能获取到对应登录时的数据.</p>
<pre><code class="language-java">@RequestMapping(&quot;/user&quot;)
@RestController
public class UserController {
    @RequestMapping(&quot;/login&quot;)
    public String login(HttpSession session, HttpServletRequest request) {
        String id = request.getParameter(&quot;id&quot;);
        String name = request.getParameter(&quot;name&quot;);
        HashMap&lt;Object, Object&gt; userInfo = new HashMap&lt;&gt;(16);
        userInfo.put(&quot;id&quot;, id);
        userInfo.put(&quot;name&quot;, name);
        session.setAttribute(&quot;USER_INFO&quot;, userInfo);
        return userInfo + &quot;  成功存储到会话中&quot;;
    }

    @RequestMapping(&quot;/getUserInfo&quot;)
    public String getUserInfo(HttpSession session, HttpServletRequest request) {
        Object user_info = session.getAttribute(&quot;USER_INFO&quot;);
        if (user_info == null) {
            return &quot;请先登录,再读取会话数据&quot;;
        }
        return &quot;从会话中读取数据 &quot; + user_info;
    }
}
</code></pre>
<p>现在我们将3个 Tomcat 实例搭建成集群,然后都运转这个项目; 如果我们针对一个 Tomcat 实例发送登录请求,然后再次发送获取用户信息请求,此时这个 Tomcat 是能够正确返回之前登录后存储的信息;而当我们在另一个 Tomcat 实例尝试获取用户信息时,则会返回 &quot;请先登录,再读取会话数据&quot;;这说明这两个 Tomcat 实例的会话信息是独立存在的.</p>
<h5 id="使用-spring-session">使用 Spring Session</h5>
<p>现在想要让这些 Tomcat 间能够对会话信息共享,只要登录一次,就可以在其他集群实例上访问数据,就可以使用 Spring Session 框架实现,它能在对程序无任何侵入的情况<br>
实现 Session 的共享.<br>
首先我们要做 POM 文件引入 Spring Session 相关的库</p>
<pre><code class="language-xml">    &lt;dependency&gt;
		&lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
		&lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;
	&lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
        &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;redis.clients&lt;/groupId&gt;
        &lt;artifactId&gt;jedis&lt;/artifactId&gt;
    &lt;/dependency&gt;
</code></pre>
<p>从依赖的库可以看到 Spring Session 利用内存数据库 Redis 来存储会话信息,以此达到集群间会话的共享.</p>
<p>引入后依赖库之后,我们就需要在 application.properties 文件上进行 Session 的配置.</p>
<pre><code>server.servlet.session.timeout=3600 //1
spring.session.redis.flush-mode=IMMEDIATE //2 
spring.session.redis.namespace=spring:session //3

// 4
spring.redis.host=127.0.0.1
spring.redis.password=
spring.redis.port=6380
</code></pre>
<p>先简单对文件新增的配置进行简单的说明:</p>
<ol>
<li>限定 Session 超时时间,默认单位为秒</li>
<li>设置 Session 刷新模式,有 ON_SAVE  和 IMMEDIATE; IMMEDIATE 表示立即写到 Redis 中;而 ON_SAVE 表示只有当执行 <code>SessionRepository.save(org.springframework.session.Session)</code> 时才会写入到 Redis.</li>
<li>存放到 Redis 中会话的命名空间.</li>
<li>连接 Redis 数据库</li>
</ol>
<p>然后在将项目打包到各个 Tomcat 之后再次调用登录请求,然后在 Redis 中查询下当前所有 KEYS<br>
<img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzllozh7ohj30i50353yh.jpg" alt=""><br>
从图里就可以看出缓存中对 Session 数据的命名就是以前配置文件中的命名空间来的,我们取一下里面的 KEY 查看它的内容,里面就有我们所存的用户信息<br>
<img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzllrin41xj316w05k0te.jpg" alt=""></p>
<p>然后我们再对另个 Tomcat 请求获取用户信息,就可以发现返回结果不再是之前的&quot;请先登录,再读取会话数据&quot;,而能正常返回在之前一台 Tomcat 实例上登录的会话数据信息.这也说明了 Tomcat 集群间的会话共享实现了, 是不是很简单呢?</p>
<h4 id="参考">参考</h4>
<ul>
<li>https://docs.spring.io/spring-session/docs/2.1.2.RELEASE/reference/html5/#samples</li>
<li>https://docs.spring.io/spring-session/docs/2.1.2.RELEASE/reference/html5/guides/boot-redis.html</li>
</ul>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://wrcj12138aaa.github.io//tag/D9rlVcx_bM" class="tag">
                    Tomcat
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://wrcj12138aaa.github.io//post/20190121-HaProxy 实现 MySQL 负载均衡">
                  <h3 class="post-title">
                    HaProxy 实现 MySQL 负载均衡
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '2ba76d6fe50ad2b384eb',
        clientSecret: '90db763ed48942571725d6aef11229900c8bb656',
        repo: 'wrcj12138aaa.github.io',
        owner: 'wrcj12138aaa',
        admin: ['wrcj12138aaa'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
