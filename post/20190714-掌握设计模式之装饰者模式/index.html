<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>闻人的技术博客</title>
<meta name="description" content="做一个终生学习的技术人" />
<link rel="shortcut icon" href="https://wrcj12138aaa.github.io//favicon.ico?v=1573983603822">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://wrcj12138aaa.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="闻人的技术博客 - Atom Feed" href="https://wrcj12138aaa.github.io//atom.xml">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://wrcj12138aaa.github.io/">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://wrcj12138aaa.github.io//images/avatar.png?v=1573983603822" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">闻人的技术博客</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E6%AD%A3%E6%96%87">正文</a>
<ul>
<li><a href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89">模式定义</a></li>
<li><a href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84">模式结构</a></li>
<li><a href="#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0">模式实现</a></li>
<li><a href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">装饰者模式使用场景</a></li>
<li><a href="#%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BE%97%E4%B8%8E%E5%A4%B1">模式的得与失</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E8%AF%AD">结语</a>
<ul>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700"></div>
    <a class="rss" href="https://wrcj12138aaa.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">掌握设计模式之装饰者模式</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2019-07-14 / 6 min read
        </div>
        
        <div class="post-content yue">
          <figure data-type="image" tabindex="1"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4ztauvhzej30p00dw45p.jpg" alt=""></figure>
<h2 id="前言">前言</h2>
<p>当应用开发中,我们要为一个对象在原有功能上进行扩展增强时,往往采用继承的方式,而继承过多时就会使得功能类更加复杂,不利于维护,而设计模式中装饰者模式可以帮助我们更好对应这种场景,装饰者模式可以做到让对象能够动态地进行功能扩展,而不影响其他对象. 那究竟它是如何实现的呢，又如何实际应用呢，就让我们一起来学习下这个模式吧。</p>
<h2 id="正文">正文</h2>
<h3 id="模式定义">模式定义</h3>
<p>装饰者模式属于结构型设计模式，首先我们先了解下装饰者模式的定义。</p>
<blockquote>
<p>In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class. The decorator pattern is often useful for adhering to the Single Responsibility Principle, as it allows functionality to be divided between classes with unique areas of concern.</p>
</blockquote>
<p>简而言之, 装饰者模式就是动态地为一个对象扩展额外的功能,无论是动态还是静态,都不影响相同类的其他对象的行为, 这样使得对象在运行时更加灵活。</p>
<p>装饰者实现的方式通常为组合或者继承,可以让客户端根据需求进行对应的装饰，来达到功能增加的目标。为了简化理解，装饰者模式中装饰一词其实就是给原来的对象添加额外功能。</p>
<h3 id="模式结构">模式结构</h3>
<p>接下来我们看下装饰者模式的层次结构和主要角色.</p>
<figure data-type="image" tabindex="2"><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwwvgxjzzbj30fs0aht9o.jpg" alt="image-20181105081809413"></figure>
<ul>
<li><code>Component</code> 抽象组件,最原始,核心的对象,通常为接口或者抽象类.</li>
<li><code>ConcreteComponent</code> 具体组件,对 <code>Component</code> 的实现,也是需要装饰的对象.</li>
<li><code>Decorator</code> 装饰者, 通常为抽象组件的抽象实现, 它的属性一定有私有变量指向 <code>Component</code>.</li>
<li><code>ConcreteDecorator</code> 具体装饰对象,是 <code>Decorator</code> 的具体实现, 用于将原始,核心的方法装饰增强的类.</li>
</ul>
<p>从图中看到，接口 <code>Component</code> 会有对应的实现类 <code>ConcerateComponent</code>，要对具体实现类进行功能增强，就需要对应的具体装饰者 <code>ConcreteDecorator</code> ，它通过内部引用  <code>Component</code> 类型的 <code>ConcerateComponent</code> 对象 ，在接口方法的默认实现上，允许添加额外的逻辑和功能代码。</p>
<h3 id="模式实现">模式实现</h3>
<p>现在我们用喝咖啡的例子来实现下装饰者模式，假设我们要买一杯咖啡，需要加糖，加奶，而什么都不加的咖啡与加奶,加糖的价格都不一样，我们就要计算调制一杯加糖加奶的咖啡需要花费多少钱。</p>
<p>这里咖啡就是我们的具体组件 <code>ConcerateComponent</code>, 奶和糖就是具体装饰对象 <code>ConcreteDecorator</code>。 为了简单,我们先创建一个<code>Component</code>接口类 <code>Drink</code>, 定义两个方法用来获得价格和描述：</p>
<pre><code class="language-java">interface Drink {
    float cost();
    String getDescription();
}
</code></pre>
<p>接着,创建一个 <code>ConcreteComponent</code> 类 <code>Coffee</code> 实现 <code>Drink</code> 接口.</p>
<pre><code class="language-java">class Coffee implements Drink {

    @Override
    public float cost() {
        return 25;
    }

    @Override
    public String getDescription() {
        return &quot;it's coffee &quot;;
    }
}
</code></pre>
<p>现在就需要一个抽象类 <code>DrinkDecorator</code>,用于扩展实现功能增强.</p>
<pre><code class="language-java">class abstract DrinkDecorator implements Drink {
    private Drink drink;
    
    public DrinkDecorator(Drink drink) {
        this.drink = drink;
    }
    
    @Override
    public float cost() {
        return drink.cost();
    }

    @Override
    public String getDescription() {
        return drink.getDescription();
    }
}
</code></pre>
<p>然后就是实现具体装饰对象 <code>Milk</code> 和 <code>Sugar</code>.</p>
<pre><code class="language-java">class Milk extends DrinkDecorator {

    public Milk(Drink drink) {
        super(drink);
    }

    @Override
    public float cost() {
        return super.cost() + 3;
    }

    @Override
    public String getDescription() {
        return super.getDescription() + &quot;with milk &quot;;
    }
}

class Sugar extends DrinkDecorator {

    public Sugar(Drink drink) {
        super(drink);
    }

    @Override
    public float cost() {
        return super.cost() + 3;
    }

    @Override
    public String getDescription() {
        return super.getDescription() + &quot;with sugar &quot;;
    }
}
</code></pre>
<p>最后客户端实现买咖啡这个动作:</p>
<pre><code class="language-java">public class DecoratorLab {
    public static void main(String[] args) {
        Drink coffee = new Coffee(); 
        System.out.println(coffee.getDescription() + &quot;,cost:&quot; + coffee.cost());//it's coffee,cost:25.0
        coffee = new Milk(coffee);
        System.out.println(coffee.getDescription() + &quot;,cost:&quot; + coffee.cost());		//it's coffee with milk,cost:28.0
        coffee = new Sugar(coffee);
        System.out.println(coffee.getDescription() + &quot;,cost:&quot; + coffee.cost());//it's coffee with milk with sugar,cost:31.0
    }
}
</code></pre>
<p>下图为示例的类图：</p>
<figure data-type="image" tabindex="3"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4zsk8axpmj313e0og40u.jpg" alt=""></figure>
<p>可以从上面例子看出,通过添加不同的材料,价格不同,并且描述信息也不一样,并且添加顺序可以动态改变,甚至不添加,让对象变得十分灵活, 这就是装饰者模式的精髓所在。</p>
<h3 id="装饰者模式使用场景">装饰者模式使用场景</h3>
<p>装饰者模式同样大量应用在 JDK 源码中,我们经常可以看到:</p>
<ul>
<li>JDK 的 IO 操作类, 比如 <a href="http://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html">java.io.InputStream</a> 体系下  <code>FilterInputStream</code> 的一系列实现类，比如 <code>BufferedInputStream</code>，<code>LineNumberInputStream</code>，<code>DataInpuStream</code>。</li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedCollection-java.util.Collection-">java.util.Collections#synchronizedXXX()</a></li>
</ul>
<p>装饰者模式可以让程序中对象在运行时中进行功能的增强和移除，并且采用更灵活的组合方式来进行扩展。</p>
<h3 id="模式的得与失">模式的得与失</h3>
<p><strong>优点</strong>:</p>
<ul>
<li>在不影响其他对象的情况下,动态为单个对象新增功能。</li>
<li>装饰类与被装饰类 (<code>ConcreteComponent</code>) 相互独立,互不耦合,易于扩展。</li>
<li>代替继承方式的功能实现,减少继承类的存在。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>
<p>装饰层次过多时会让被装饰的对象更复杂，不容易理解，比如使用 Java I/O 的 <code>DataInputStream</code> 对象读取数据为 Java 基本类型值时会这样使用：</p>
<pre><code class="language-java">DataInputStream is = new DataInputStream(new BufferedInputStream(new FileInputStream(file)));
</code></pre>
</li>
<li>
<p>程序中若有太多的装饰类，理解和使用上略有难度。</p>
</li>
</ul>
<h2 id="结语">结语</h2>
<p>掌握装饰者模式的精髓在于通过一层层的包装,让原来对象的功能更加强大,且包装过程是动态的,灵活可以移除的,到最后还是会调用到原对象最原始的功能。</p>
<h3 id="参考">参考</h3>
<ul>
<li>https://www.journaldev.com/1540/decorator-design-pattern-in-java-example</li>
<li>https://java-design-patterns.com/patterns/decorator/</li>
<li>《设计模式之禅》：https://book.douban.com/subject/4260618/</li>
<li>https://javadoop.com/post/design-pattern</li>
</ul>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://wrcj12138aaa.github.io//tag/llypUO29A">
            <span class="flex-auto">Java</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://wrcj12138aaa.github.io//tag/RVSTCL07Eh">
            <span class="flex-auto">设计模式</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://wrcj12138aaa.github.io//post/20190721-如何优雅关闭 Spring Boot 应用">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  如何优雅关闭 Spring Boot 应用
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://wrcj12138aaa.github.io//post/20190707-YApi使用指南">
                <h3 class="post-title">
                  YApi使用指南
                  <i class="remixicon-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '2ba76d6fe50ad2b384eb',
    clientSecret: '90db763ed48942571725d6aef11229900c8bb656',
    repo: 'wrcj12138aaa.github.io',
    owner: 'wrcj12138aaa',
    admin: ['wrcj12138aaa'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://wrcj12138aaa.github.io//media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
