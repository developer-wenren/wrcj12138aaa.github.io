<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Spring Boot 快速集成 Ehcache3 | 闻人的技术博客</title>
<meta name="description" content="做一个终生学习的技术人">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://wrcj12138aaa.github.io//favicon.ico?v=1574522179527">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://wrcj12138aaa.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://wrcj12138aaa.github.io/">
        <img src="https://wrcj12138aaa.github.io//images/avatar.png?v=1574522179527" class="site-logo">
        <h1 class="site-title">闻人的技术博客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      做一个终生学习的技术人
    </div>
    <div class="site-footer">
       | <a class="rss" href="https://wrcj12138aaa.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Spring Boot 快速集成 Ehcache3</h2>
            <div class="post-date">2019-02-17</div>
            
            <div class="post-content">
              <h2 id="前言">前言</h2>
<p>在互联网服务端架构中，缓存的作用是尤为重要的，无论是基于服务器的内存缓存如 Redis，还是 基于 JVM 的内存缓存如 Ehcache ，在高并发场景中承载着巨大的流量，本文主要针对  JVM 内存框架 Ehcache 3 进行简单地练习，基于Spring Boot 集成 Ehcache 3 搭建一个简单的项目，来实现程序的内存缓存功能支持。</p>
<!--more-->
<h2 id="正文">正文</h2>
<h3 id="ehcache-3">Ehcache 3</h3>
<p><a href="https://www.ehcache.org/">Ehcache</a> 是一个开源，具有高性能的 Java 缓存库，由于使用简单，扩展性强，是使用最广泛的 Java 缓存框架，同时具备了内存缓存和磁盘缓存的能力，最新的版本是 Ehcache 3.6。</p>
<h3 id="集成步骤">集成步骤</h3>
<ol>
<li>
<p>首先创建一个基本的 Spring Boot 程序取名为 <code>springboot-ehcache</code>，（版本为 2.1.3，以 maven 作为构建工具，不选择任何依赖。（本项目采用 IDEA 2018.5）</p>
</li>
<li>
<p>在项目的 pom.xml 里添加 Ehcache 3 依赖，选择合适的版本，这里采用了3.0.0。</p>
</li>
</ol>
<p>pom.xml</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.ehcache&lt;/groupId&gt;
  &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
  &lt;version&gt;3.0.0&lt;/version&gt;    
 &lt;/dependency&gt;
</code></pre>
<ol start="3">
<li>
<p>在项目的 pom.xml 里添加 JSR-107 API 依赖</p>
<blockquote>
<p>关于  JSR-107 API：Java 缓存规范的文档 API，类似 JDBC 规范。</p>
</blockquote>
<p>pom.xml</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.cache&lt;/groupId&gt;
    &lt;artifactId&gt;cache-api&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>添加 Spring Boot 依赖</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; 
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<blockquote>
<p>前两个依赖是 Spring Boot 程序 创建时默认有的，这里的 <code>spring-boot-starter-cache</code> 就是使用 Spring 框架的缓存功能，而加入了 <code>spring-boot-starter-web</code> 主要为了引入 Spring MVC，方便测试缓存的效果。</p>
</blockquote>
</li>
<li>
<p>在程序配置文件 application.properties 中指定 ehcache.xml 的路径,一般放置在当前 classpath 下；这样就让 Spring 缓存启用 Ehcache。</p>
<p>application.properties</p>
<pre><code>spring.cache.jcache.config=classpath:ehcache.xml
</code></pre>
</li>
<li>
<p>在项目里启用缓存，有注解和 XML 配置两种方式</p>
</li>
</ol>
<ul>
<li>
<p>使用  @EnableCaching  注解</p>
<pre><code class="language-java">// com.one.springbootehcache2.SpringbootEhcacheApplication.java 
@EnableCaching
@SpringBootApplication
public class SpringbootEhcacheApplication
{
    public static void main(String[] args)
    {
        SpringApplication.run(SpringbootEhcacheApplication.class, args);
    }
}
</code></pre>
</li>
<li>
<p>或者在 Spring 的 XML 文件中添加 <code>&lt;cache:annotation-driven /&gt;</code></p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd&quot;&gt;

    &lt;cache:annotation-driven /&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ul>
<ol start="7">
<li>
<p>在需要使用缓存的方法上使用注解 @CacheResult 进行声明，这样一旦调用这个方法，返回的结果就会被缓存，除非缓存被清除掉，下次就不会执行方法的逻辑了。</p>
<p>PersonService.java</p>
<pre><code class="language-java">// com.one.springbootehcache.service.PersonService.java
@Service
public class PersonService {
    @CacheResult(cacheName=&quot;people&quot;)
    Person getPerson(int id) {
        System.out.println(&quot;未从缓存读取 &quot; + id);
        switch (id) {
            case 1:
                return new Person(id, &quot;Steve&quot;, &quot;jobs&quot;);
            case 2:
                return new Person(id, &quot;bill&quot;, &quot;gates&quot;);
            default:
                return new Person(id, &quot;unknown&quot;, &quot;unknown&quot;);
        }
    }
}
</code></pre>
<p>Person.java</p>
<pre><code class="language-java">// com.one.springbootehcache.domain.Person.java 
public class Person implements Serializable {
        private int id;
        private String firstName;
        private String lastName;

        public Person(int id, String firstName, String lastName) {
            this.id =id;
            this.firstName = firstName;
            this.lastName = lastName;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public String getFirstName() {
            return firstName;
        }

        public void setFirstName(String firstName) {
            this.firstName = firstName;
        }

        public String getLastName() {
            return lastName;
        }

        public void setLastName(String lastName) {
            this.lastName = lastName;
        }
}
</code></pre>
<ul>
<li>@CacheResult 必须指定 cacheName，否则 cacheName 默认视为该方法名称。</li>
</ul>
</li>
<li>
<p>在 ehcache.xml  配置基本缓存参数</p>
<p>ehcache.xml</p>
<pre><code class="language-xml">&lt;config
    xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
    xmlns='http://www.ehcache.org/v3'  
    xmlns:jsr107='http://www.ehcache.org/v3/jsr107'&gt;  

  &lt;service&gt;
    &lt;jsr107:defaults&gt;
      &lt;jsr107:cache name=&quot;people&quot; template=&quot;heap-cache&quot;/&gt; 
    &lt;/jsr107:defaults&gt;
  &lt;/service&gt;

  &lt;cache-template name=&quot;heap-cache&quot;&gt;
    &lt;listeners&gt;    
      &lt;listener&gt;
        &lt;class&gt;com.one.springbootehcache.config.EventLogger&lt;/class&gt;
        &lt;event-firing-mode&gt;ASYNCHRONOUS&lt;/event-firing-mode&gt;
        &lt;event-ordering-mode&gt;UNORDERED&lt;/event-ordering-mode&gt;
        &lt;events-to-fire-on&gt;CREATED&lt;/events-to-fire-on&gt; 
        &lt;events-to-fire-on&gt;UPDATED&lt;/events-to-fire-on&gt; 
        &lt;events-to-fire-on&gt;EXPIRED&lt;/events-to-fire-on&gt; 
        &lt;events-to-fire-on&gt;REMOVED&lt;/events-to-fire-on&gt; 
      &lt;/listener&gt;
    &lt;/listeners&gt;
    &lt;resources&gt;
      &lt;heap unit=&quot;entries&quot;&gt;2000&lt;/heap&gt; 
      &lt;offheap unit=&quot;MB&quot;&gt;100&lt;/offheap&gt; 
    &lt;/resources&gt;
  &lt;/cache-template&gt;
&lt;/config&gt;
</code></pre>
<ul>
<li>
<p>声明一个名为 people 的缓存,指定 heap-cache 为模板</p>
</li>
<li>
<p>在缓存模板里配置了日志输入器 EventLogger，用来监听缓存数据变更的事件，例如数据创建，更新，失效等进行事件日志输出。</p>
<pre><code class="language-java">//com.one.springbootehcache.config.EventLogger.java
public class EventLogger implements CacheEventListener&lt;Object, Object&gt; {

    private static final Logger LOGGER = LoggerFactory.getLogger(EventLogger.class);

    @Override
    public void onEvent(CacheEvent&lt;Object, Object&gt; event) {
        LOGGER.info(&quot;Event: &quot; + event.getType() + &quot; Key: &quot; + event.getKey() + &quot; old value: &quot; + event.getOldValue() + &quot; new value: &quot; + event.getNewValue());
    }

}
</code></pre>
</li>
<li>
<p>对 CREATED，UPDATED，EXPIRED，REMOVED 这四个事件进行监听。</p>
</li>
<li>
<p>最后的 resources 元素配置了缓存能容纳的最大对象个数为2000，堆外内存容量为100M。</p>
</li>
</ul>
</li>
<li>
<p>实现  <code>JCacheManagerCustomizer.customize(CacheManager cacheManager)</code>  方法在 CacheManager 使用之前，创建我们配置文件定义的缓存,并声明了缓存策略为10秒。</p>
<pre><code class="language-java">// com.one.springbootehcache.config.CachingSetup.java
@Component
public  class CachingSetup implements JCacheManagerCustomizer {
    @Override
    public void customize(CacheManager cacheManager)
    {
      cacheManager.createCache(&quot;people&quot;, new MutableConfiguration&lt;&gt;()  
        .setExpiryPolicyFactory(TouchedExpiryPolicy.factoryOf(new Duration(SECONDS, 10))) 
        .setStoreByValue(false)
        .setStatisticsEnabled(true));
    }
}
</code></pre>
</li>
<li>
<p>创建一个控制器 PersonController，进行缓存的测试。</p>
<pre><code class="language-java">// com.one.springbootehcache.domain.Person.java
@RequestMapping(&quot;/person&quot;)
@RestController
public class PersonController {
    private static final Logger LOGGER = LoggerFactory.getLogger(PersonController.class);

    @Autowired
    private PersonService personService;

    @RequestMapping(&quot;/get&quot;)
    public Person getPerson(int id) {
        Person person = personService.getPerson(id);
        LOGGER.info(&quot;读取到数据 &quot; + person.getFirstName() + &quot;,&quot; + person.getLastName());
        return person;
    }
}
</code></pre>
<p>启动程序，快速两次访问 <code>http://localhost:8080/person/get?id=1</code>，可以从控制台看到如下结果：</p>
<figure data-type="image" tabindex="1"><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0da1djadej318y02wdft.jpg" alt=""></figure>
<p>可以看出第二次访问时，直接使用的先前缓存的数据。由于缓存过期策略设置为 10秒，过了10秒再访问一次查看日志，可以根据事件日志器看出缓存失效后重新获取的数据，再添加到缓存中去。</p>
<figure data-type="image" tabindex="2"><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0da3rk4s1j31ai03hglq.jpg" alt=""></figure>
</li>
</ol>
<p>到这里，我们的 Ehcache 3 与 Spring Boot 集成整合就算完成了，虽然项目比较简单，但可以基于此参考更详细的 Ehcache 配置来进行扩展。</p>
<h3 id="问题列表">问题列表</h3>
<p>下面是我搭建项目过程中踩到的坑，这里放出来，希望能对同样遇到问题的同学有所参考。</p>
<ul>
<li>**问题一：实体类未实现 java.io.Serializable 接口 **</li>
</ul>
<pre><code>2019-02-17 15:50:07.606 ERROR 29671 --- [nio-8080-exec-4] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.data.redis.serializer.SerializationException: Cannot serialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to serialize object using DefaultSerializer; nested exception is java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [com.one.springbootehcache.domain.Person]] with root cause 
java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [com.one.springbootehcache.domain.Person] 
</code></pre>
<blockquote>
<p>解决办法：Ehcahe 需要缓存的实体类必须实现 java.io.Serializable 接口</p>
</blockquote>
<ul>
<li><strong>问题二：注解 @CacheResult 未指定缓存名称</strong></li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0d9v75yp1j31hs07q3zo.jpg" alt=""></figure>
<blockquote>
<p>解决办法：@CacheResult 的 cacheName 必须指定配置创建的缓存 ，否则 cacheName 默认为该方法完全名称。</p>
</blockquote>
<ul>
<li><strong>问题三：没有正确定义 事件日志器，导致 cacheManager 创建缓存出错</strong></li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0damghmklj31fv05u0ux.jpg" alt=""></figure>
<blockquote>
<p>解决办法：在 ehcache.xml  定义的 Listener 类实现 接口 <code>CacheEventListener</code>。</p>
</blockquote>
<h2 id="结语">结语</h2>
<p>希望文章对你有所帮助，如果觉得还行，不妨点个赞吧。<sup>_</sup></p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://wrcj12138aaa.github.io//tag/pZ9nnv4urc" class="tag">
                    Spring Boot
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://wrcj12138aaa.github.io//post/20190128-快速实现 Tomcat 集群 Session 共享">
                  <h3 class="post-title">
                    快速实现 Tomcat 集群 Session 共享
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '2ba76d6fe50ad2b384eb',
        clientSecret: '90db763ed48942571725d6aef11229900c8bb656',
        repo: 'wrcj12138aaa.github.io',
        owner: 'wrcj12138aaa',
        admin: ['wrcj12138aaa'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
