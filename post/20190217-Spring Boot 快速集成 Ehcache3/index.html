<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>闻人的技术博客</title>
<meta name="description" content="做一个终生学习的技术人" />
<link rel="shortcut icon" href="https://wrcj12138aaa.github.io//favicon.ico?v=1574521603262">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://wrcj12138aaa.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="闻人的技术博客 - Atom Feed" href="https://wrcj12138aaa.github.io//atom.xml">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://wrcj12138aaa.github.io/">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://wrcj12138aaa.github.io//images/avatar.png?v=1574521603262" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">闻人的技术博客</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E6%AD%A3%E6%96%87">正文</a>
<ul>
<li><a href="#ehcache-3">Ehcache 3</a></li>
<li><a href="#%E9%9B%86%E6%88%90%E6%AD%A5%E9%AA%A4">集成步骤</a></li>
<li><a href="#%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8">问题列表</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700"></div>
    <a class="rss" href="https://wrcj12138aaa.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">Spring Boot 快速集成 Ehcache3</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2019-02-17 / 10 min read
        </div>
        
        <div class="post-content yue">
          <h2 id="前言">前言</h2>
<p>在互联网服务端架构中，缓存的作用是尤为重要的，无论是基于服务器的内存缓存如 Redis，还是 基于 JVM 的内存缓存如 Ehcache ，在高并发场景中承载着巨大的流量，本文主要针对  JVM 内存框架 Ehcache 3 进行简单地练习，基于Spring Boot 集成 Ehcache 3 搭建一个简单的项目，来实现程序的内存缓存功能支持。</p>
<!--more-->
<h2 id="正文">正文</h2>
<h3 id="ehcache-3">Ehcache 3</h3>
<p><a href="https://www.ehcache.org/">Ehcache</a> 是一个开源，具有高性能的 Java 缓存库，由于使用简单，扩展性强，是使用最广泛的 Java 缓存框架，同时具备了内存缓存和磁盘缓存的能力，最新的版本是 Ehcache 3.6。</p>
<h3 id="集成步骤">集成步骤</h3>
<ol>
<li>
<p>首先创建一个基本的 Spring Boot 程序取名为 <code>springboot-ehcache</code>，（版本为 2.1.3，以 maven 作为构建工具，不选择任何依赖。（本项目采用 IDEA 2018.5）</p>
</li>
<li>
<p>在项目的 pom.xml 里添加 Ehcache 3 依赖，选择合适的版本，这里采用了3.0.0。</p>
</li>
</ol>
<p>pom.xml</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.ehcache&lt;/groupId&gt;
  &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
  &lt;version&gt;3.0.0&lt;/version&gt;    
 &lt;/dependency&gt;
</code></pre>
<ol start="3">
<li>
<p>在项目的 pom.xml 里添加 JSR-107 API 依赖</p>
<blockquote>
<p>关于  JSR-107 API：Java 缓存规范的文档 API，类似 JDBC 规范。</p>
</blockquote>
<p>pom.xml</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.cache&lt;/groupId&gt;
    &lt;artifactId&gt;cache-api&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>添加 Spring Boot 依赖</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; 
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<blockquote>
<p>前两个依赖是 Spring Boot 程序 创建时默认有的，这里的 <code>spring-boot-starter-cache</code> 就是使用 Spring 框架的缓存功能，而加入了 <code>spring-boot-starter-web</code> 主要为了引入 Spring MVC，方便测试缓存的效果。</p>
</blockquote>
</li>
<li>
<p>在程序配置文件 application.properties 中指定 ehcache.xml 的路径,一般放置在当前 classpath 下；这样就让 Spring 缓存启用 Ehcache。</p>
<p>application.properties</p>
<pre><code>spring.cache.jcache.config=classpath:ehcache.xml
</code></pre>
</li>
<li>
<p>在项目里启用缓存，有注解和 XML 配置两种方式</p>
</li>
</ol>
<ul>
<li>
<p>使用  @EnableCaching  注解</p>
<pre><code class="language-java">// com.one.springbootehcache2.SpringbootEhcacheApplication.java 
@EnableCaching
@SpringBootApplication
public class SpringbootEhcacheApplication
{
    public static void main(String[] args)
    {
        SpringApplication.run(SpringbootEhcacheApplication.class, args);
    }
}
</code></pre>
</li>
<li>
<p>或者在 Spring 的 XML 文件中添加 <code>&lt;cache:annotation-driven /&gt;</code></p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd&quot;&gt;

    &lt;cache:annotation-driven /&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ul>
<ol start="7">
<li>
<p>在需要使用缓存的方法上使用注解 @CacheResult 进行声明，这样一旦调用这个方法，返回的结果就会被缓存，除非缓存被清除掉，下次就不会执行方法的逻辑了。</p>
<p>PersonService.java</p>
<pre><code class="language-java">// com.one.springbootehcache.service.PersonService.java
@Service
public class PersonService {
    @CacheResult(cacheName=&quot;people&quot;)
    Person getPerson(int id) {
        System.out.println(&quot;未从缓存读取 &quot; + id);
        switch (id) {
            case 1:
                return new Person(id, &quot;Steve&quot;, &quot;jobs&quot;);
            case 2:
                return new Person(id, &quot;bill&quot;, &quot;gates&quot;);
            default:
                return new Person(id, &quot;unknown&quot;, &quot;unknown&quot;);
        }
    }
}
</code></pre>
<p>Person.java</p>
<pre><code class="language-java">// com.one.springbootehcache.domain.Person.java 
public class Person implements Serializable {
        private int id;
        private String firstName;
        private String lastName;

        public Person(int id, String firstName, String lastName) {
            this.id =id;
            this.firstName = firstName;
            this.lastName = lastName;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public String getFirstName() {
            return firstName;
        }

        public void setFirstName(String firstName) {
            this.firstName = firstName;
        }

        public String getLastName() {
            return lastName;
        }

        public void setLastName(String lastName) {
            this.lastName = lastName;
        }
}
</code></pre>
<ul>
<li>@CacheResult 必须指定 cacheName，否则 cacheName 默认视为该方法名称。</li>
</ul>
</li>
<li>
<p>在 ehcache.xml  配置基本缓存参数</p>
<p>ehcache.xml</p>
<pre><code class="language-xml">&lt;config
    xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
    xmlns='http://www.ehcache.org/v3'  
    xmlns:jsr107='http://www.ehcache.org/v3/jsr107'&gt;  

  &lt;service&gt;
    &lt;jsr107:defaults&gt;
      &lt;jsr107:cache name=&quot;people&quot; template=&quot;heap-cache&quot;/&gt; 
    &lt;/jsr107:defaults&gt;
  &lt;/service&gt;

  &lt;cache-template name=&quot;heap-cache&quot;&gt;
    &lt;listeners&gt;    
      &lt;listener&gt;
        &lt;class&gt;com.one.springbootehcache.config.EventLogger&lt;/class&gt;
        &lt;event-firing-mode&gt;ASYNCHRONOUS&lt;/event-firing-mode&gt;
        &lt;event-ordering-mode&gt;UNORDERED&lt;/event-ordering-mode&gt;
        &lt;events-to-fire-on&gt;CREATED&lt;/events-to-fire-on&gt; 
        &lt;events-to-fire-on&gt;UPDATED&lt;/events-to-fire-on&gt; 
        &lt;events-to-fire-on&gt;EXPIRED&lt;/events-to-fire-on&gt; 
        &lt;events-to-fire-on&gt;REMOVED&lt;/events-to-fire-on&gt; 
      &lt;/listener&gt;
    &lt;/listeners&gt;
    &lt;resources&gt;
      &lt;heap unit=&quot;entries&quot;&gt;2000&lt;/heap&gt; 
      &lt;offheap unit=&quot;MB&quot;&gt;100&lt;/offheap&gt; 
    &lt;/resources&gt;
  &lt;/cache-template&gt;
&lt;/config&gt;
</code></pre>
<ul>
<li>
<p>声明一个名为 people 的缓存,指定 heap-cache 为模板</p>
</li>
<li>
<p>在缓存模板里配置了日志输入器 EventLogger，用来监听缓存数据变更的事件，例如数据创建，更新，失效等进行事件日志输出。</p>
<pre><code class="language-java">//com.one.springbootehcache.config.EventLogger.java
public class EventLogger implements CacheEventListener&lt;Object, Object&gt; {

    private static final Logger LOGGER = LoggerFactory.getLogger(EventLogger.class);

    @Override
    public void onEvent(CacheEvent&lt;Object, Object&gt; event) {
        LOGGER.info(&quot;Event: &quot; + event.getType() + &quot; Key: &quot; + event.getKey() + &quot; old value: &quot; + event.getOldValue() + &quot; new value: &quot; + event.getNewValue());
    }

}
</code></pre>
</li>
<li>
<p>对 CREATED，UPDATED，EXPIRED，REMOVED 这四个事件进行监听。</p>
</li>
<li>
<p>最后的 resources 元素配置了缓存能容纳的最大对象个数为2000，堆外内存容量为100M。</p>
</li>
</ul>
</li>
<li>
<p>实现  <code>JCacheManagerCustomizer.customize(CacheManager cacheManager)</code>  方法在 CacheManager 使用之前，创建我们配置文件定义的缓存,并声明了缓存策略为10秒。</p>
<pre><code class="language-java">// com.one.springbootehcache.config.CachingSetup.java
@Component
public  class CachingSetup implements JCacheManagerCustomizer {
    @Override
    public void customize(CacheManager cacheManager)
    {
      cacheManager.createCache(&quot;people&quot;, new MutableConfiguration&lt;&gt;()  
        .setExpiryPolicyFactory(TouchedExpiryPolicy.factoryOf(new Duration(SECONDS, 10))) 
        .setStoreByValue(false)
        .setStatisticsEnabled(true));
    }
}
</code></pre>
</li>
<li>
<p>创建一个控制器 PersonController，进行缓存的测试。</p>
<pre><code class="language-java">// com.one.springbootehcache.domain.Person.java
@RequestMapping(&quot;/person&quot;)
@RestController
public class PersonController {
    private static final Logger LOGGER = LoggerFactory.getLogger(PersonController.class);

    @Autowired
    private PersonService personService;

    @RequestMapping(&quot;/get&quot;)
    public Person getPerson(int id) {
        Person person = personService.getPerson(id);
        LOGGER.info(&quot;读取到数据 &quot; + person.getFirstName() + &quot;,&quot; + person.getLastName());
        return person;
    }
}
</code></pre>
<p>启动程序，快速两次访问 <code>http://localhost:8080/person/get?id=1</code>，可以从控制台看到如下结果：</p>
<figure data-type="image" tabindex="1"><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0da1djadej318y02wdft.jpg" alt=""></figure>
<p>可以看出第二次访问时，直接使用的先前缓存的数据。由于缓存过期策略设置为 10秒，过了10秒再访问一次查看日志，可以根据事件日志器看出缓存失效后重新获取的数据，再添加到缓存中去。</p>
<figure data-type="image" tabindex="2"><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0da3rk4s1j31ai03hglq.jpg" alt=""></figure>
</li>
</ol>
<p>到这里，我们的 Ehcache 3 与 Spring Boot 集成整合就算完成了，虽然项目比较简单，但可以基于此参考更详细的 Ehcache 配置来进行扩展。</p>
<h3 id="问题列表">问题列表</h3>
<p>下面是我搭建项目过程中踩到的坑，这里放出来，希望能对同样遇到问题的同学有所参考。</p>
<ul>
<li>**问题一：实体类未实现 java.io.Serializable 接口 **</li>
</ul>
<pre><code>2019-02-17 15:50:07.606 ERROR 29671 --- [nio-8080-exec-4] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.data.redis.serializer.SerializationException: Cannot serialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to serialize object using DefaultSerializer; nested exception is java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [com.one.springbootehcache.domain.Person]] with root cause 
java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [com.one.springbootehcache.domain.Person] 
</code></pre>
<blockquote>
<p>解决办法：Ehcahe 需要缓存的实体类必须实现 java.io.Serializable 接口</p>
</blockquote>
<ul>
<li><strong>问题二：注解 @CacheResult 未指定缓存名称</strong></li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0d9v75yp1j31hs07q3zo.jpg" alt=""></figure>
<blockquote>
<p>解决办法：@CacheResult 的 cacheName 必须指定配置创建的缓存 ，否则 cacheName 默认为该方法完全名称。</p>
</blockquote>
<ul>
<li><strong>问题三：没有正确定义 事件日志器，导致 cacheManager 创建缓存出错</strong></li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0damghmklj31fv05u0ux.jpg" alt=""></figure>
<blockquote>
<p>解决办法：在 ehcache.xml  定义的 Listener 类实现 接口 <code>CacheEventListener</code>。</p>
</blockquote>
<h2 id="结语">结语</h2>
<p>希望文章对你有所帮助，如果觉得还行，不妨点个赞吧。<sup>_</sup></p>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://wrcj12138aaa.github.io//tag/pZ9nnv4urc">
            <span class="flex-auto">Spring Boot</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://wrcj12138aaa.github.io//post/20190218-中文技术文档的写作规范">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  中文技术写作规范摘要
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://wrcj12138aaa.github.io//post/20190128-快速实现 Tomcat 集群 Session 共享">
                <h3 class="post-title">
                  快速实现 Tomcat 集群 Session 共享
                  <i class="remixicon-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '2ba76d6fe50ad2b384eb',
    clientSecret: '90db763ed48942571725d6aef11229900c8bb656',
    repo: 'wrcj12138aaa.github.io',
    owner: 'wrcj12138aaa',
    admin: ['wrcj12138aaa'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://wrcj12138aaa.github.io//media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
