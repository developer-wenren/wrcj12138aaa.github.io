<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>闻人的技术博客</title>
<meta name="description" content="做一个终生学习者" />
<link rel="shortcut icon" href="https://wrcj12138aaa.github.io//favicon.ico?v=1570431630819">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://wrcj12138aaa.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="闻人的技术博客 - Atom Feed" href="https://wrcj12138aaa.github.io//atom.xml">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://wrcj12138aaa.github.io/">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://wrcj12138aaa.github.io//images/avatar.png?v=1570431630819" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">闻人的技术博客</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E8%AE%A4%E8%AF%86-scala">认识 Scala</a>
<ul>
<li><a href="#scala-%E7%9A%84%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7">Scala 的语言特性</a></li>
</ul>
</li>
<li><a href="#scala-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">Scala 环境搭建</a></li>
<li><a href="#scala-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BA%A4%E4%BA%92">Scala 命令行交互</a><br>
*
<ul>
<li><a href="#scala-repl">Scala REPL</a></li>
<li><a href="#%E7%BC%96%E8%AF%91-scala-%E7%B1%BB">编译 Scala 类</a></li>
</ul>
</li>
<li><a href="#scala-%E8%AF%AD%E6%B3%95">Scala 语法</a>
<ul>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a>
<ul>
<li><a href="#nothing-%E5%92%8C-null">Nothing 和 Null</a></li>
<li><a href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">值类型转换</a></li>
</ul>
</li>
<li><a href="#%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0">方法/函数</a></li>
<li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">流程控制</a>
<ul>
<li><a href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD">条件判断</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E5%A4%84%E7%90%86">循环处理</a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB">类</a>
<ul>
<li><a href="#%E6%9E%84%E9%80%A0%E5%99%A8">构造器</a></li>
<li><a href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C-gettersetter-%E8%AF%AD%E6%B3%95">成员变量和 Getter/Setter 语法</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF%E9%87%8D%E5%86%99">继承重写</a></li>
<li><a href="#trait">Trait</a></li>
<li><a href="#case-class">Case Class</a></li>
<li><a href="#%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1">单例对象</a></li>
<li><a href="#tuple-%E5%85%83%E7%BB%84">Tuple 元组</a></li>
</ul>
</li>
<li><a href="#%E9%9B%86%E5%90%88">集合</a>
<ul>
<li><a href="#set">Set</a></li>
<li><a href="#map">Map</a></li>
<li><a href="#%E6%95%B0%E7%BB%84">数组</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#scala-%E5%AE%9E%E6%88%98scala-spring-boot">Scala 实战：Scala + Spring Boot</a></li>
<li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700"></div>
    <a class="rss" href="https://wrcj12138aaa.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">Java开发看的Scala入门</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2019-06-09 / 21 min read
        </div>
        
        <div class="post-content yue">
          <figure data-type="image" tabindex="1"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3uqfddf10j30p00dwtat.jpg" alt="每篇一句"></figure>
<h2 id="前言">前言</h2>
<p>对于 Scala 语言其实很早有所耳闻，但没有真正进一步了解，只知道这门语言在大数据领域很火。正如前几年大数据开发的兴起，也着实让这门基于 JVM 的语言火了一把。由于近期开始参与公司的大数据项目，面对大数据量计算处理需求，基于目前自己 Java 的技术栈远远不够，不得不引入 Spark 之类的大数据框架，而 Spark 是由 Scala 编写的，虽说 Spark 提供 Java API，但为了能更好了使用 Spark 和及时排查可能遇到的问题，还是有必要全面学习下 Scala 这门语言。</p>
<p>本文主要内容涉及如下：</p>
<ul>
<li>Scala 基本介绍</li>
<li>Scala 语法特性介绍</li>
<li>Scala 与 SpringBoot 实战</li>
</ul>
<blockquote>
<p>示例项目：https://github.com/wrcj12138aaa/scala-actions</p>
<p>环境支持：</p>
<ul>
<li>JDK 8</li>
<li>SpringBoot 2.1.5</li>
<li>Maven 3.6.0</li>
<li>Scala 2.12.8</li>
</ul>
</blockquote>
<h2 id="认识-scala">认识 Scala</h2>
<p>在认识 Scala 之前，我们先来弄清楚 Scala 的读法和来历。尤其是作为中国程序员，头疼的就是面对新技术出现的单词，自己却读不出来或者读得很变扭，这里我在<a href="https://fanyi.baidu.com/?aldtype=16047#en/zh/Scala">百度翻译</a>中查到了 Scala 的音标 <code>[ˈskɑlə]</code> 和单词发音，可以供大家参考。</p>
<p>接着再简单看下 Scala 的历史：Scala 是由洛桑联邦理工学院的 Martin Odersky 教授主导设计的一门编程语言，面对 Java 严格的语言规范限制，Martin 教授基于 JVM 重新设计了一门更加现代化，可扩展的语言， 并且将这门 Scalable Language 的缩写 Scala 作为命名，这就是 Scala 的来由。从 2003 年底基于 Java 平台的 Scala 发布，到现在稳定版本已经到了 2.12.8，可以说 Scala 的迭代速度还是很快的</p>
<p>好了说到正题，要学习 Scala 这门编程语言，首先来解读下官方对 Scala 的描述：</p>
<blockquote>
<p>Scala combines object-oriented and functional programming in one concise, high-level language. Scala's static types help avoid bugs in complex applications, and its JVM and JavaScript runtimes let you build high-performance systems with easy access to huge ecosystems of libraries.</p>
</blockquote>
<p>从上面这段话里，我们可以提取到以下信息：</p>
<ol>
<li>Scala 是一门静态类型的高级编程语言，结合了面对对象和面向函数编程的特性。</li>
<li>Scala 可以运行在 JVM 以及 JavaScript 运行时环境上。</li>
<li>Scala 常用于构建高性能程序和框架。</li>
</ol>
<p>关于 Scala 语言的丰富特性我们将在下文的 Scala 语法 一节去学习和感受；而针对构建高性能程序和框架这一点，目前大数据库领域的项目框架 Spark，Flink，Kafka 等都是基于 Scala 开发的，说明了使用 Scala 对高性能场景下的帮助是毫无疑问的。</p>
<h3 id="scala-的语言特性">Scala 的语言特性</h3>
<ul>
<li>既是属于面向对象的语言，也是函数式语言</li>
<li>静态类型语言，这一点跟 Java 一样，但还支持类型推断</li>
<li>与 Java 生态无缝接合，可以调用 Java 库以及与 Java 混合开发</li>
<li>可扩展性，可以根据自身需要定制扩展语言的功能</li>
</ul>
<p>整体了解 Scala 之后，接下来我们就开始快速搭建 Scala 环境，然后写我们的第一行 Scala 代码吧。</p>
<h2 id="scala-环境搭建">Scala 环境搭建</h2>
<p>搭建 Scala 环境其实很简单，类比配置 Java 语言环境的经历，总结下来就两步骤：</p>
<blockquote>
<p>注意：下载 Scala 安装包之前，需要本机环境有 JDK 8 以上 才行。</p>
</blockquote>
<ol>
<li>
<p>从<a href="https://www.scala-lang.org/download/">Scala 官网</a>下载 2.12.8 版本的语言压缩包，并解压到本地磁盘。</p>
<figure data-type="image" tabindex="2"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3t3e2xzjtj30u00uxadp.jpg" alt="image-20190608011135438"></figure>
</li>
<li>
<p>添加 Scala 环境变量，指定为所解压的 Scala 文件夹，由于我本机为 Mac 环境，所以只需在 Shell 配置文件里操作即可，修改 Shell 配置文件 <code>~/.bash_profile</code> 文件底部添加下面内容, 使用命令<code>source ~/.bash_profile</code> 使配置生效。</p>
<figure data-type="image" tabindex="3"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3tjwzlrcwj311s08caam.jpg" alt="carbon"></figure>
</li>
</ol>
<p>完成上述步骤后，命令行输入 <code>scala -version</code> 得到跟下图内容一样时就表示 Scala 语言环境搞定了。</p>
<figure data-type="image" tabindex="4"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3t48j43tkj316a06eq3h.jpg" alt="查看 Scala 版本"></figure>
<h2 id="scala-命令行交互">Scala 命令行交互</h2>
<h4 id="scala-repl">Scala REPL</h4>
<p>不同于 Java，Scala 还提供了命令行模式下的交互，专业说法为 REPL(Read-eval-print-loop)，详细介绍可以参见<a href="https://docs.scala-lang.org/overviews/repl/overview.html">Scala REPL OVERVIEW</a>；基于此我们可以直接在命令行上使用 Scala 语言，如果有过 Python 或者 Node.js 的同学应该会熟悉这个编程交互方式。</p>
<p>首先在命令行里输入 <code>scala</code> 进去交互模式，然后输入 <code>println(&quot;Hello,Scala&quot;)</code> 回车，这样一个最简单的 Scala 版 HelloWorld 就是完成了。</p>
<figure data-type="image" tabindex="5"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3t4h6wz94j311s0i2q40.jpg" alt="REPL"></figure>
<p>这里使用到的 <code>println</code>就是 Scala 中的打印方法，类似 Java 中的<code>System.out.println</code>，是不是很简洁呢。</p>
<h4 id="编译-scala-类">编译 Scala 类</h4>
<p>除了使用命令行交互方式之外，我们再试着实现一个 Scala 类的 HelloWorld。</p>
<p>首先新建一个 <code>HelloWorld.scala</code> 文件, 写一个 <code>main</code> 方法。</p>
<figure data-type="image" tabindex="6"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3upe2vzdaj311s09i0tl.jpg" alt="HelloWord.scala"></figure>
<p>看起来，Scala 的写法跟 Java 的 <code>main</code> 方法是不是很不一样呢，先试着跑起来，我们后面再对语法进一步学习。</p>
<p>接下来就需要对源代码进行编译运行了，类似 Java ，Scala 库提供了 Scala 编译器工具 scalac，可以对 Scala 文件编译成字节码；还有解释器工具 <code>scala</code> 用于运行字节码。</p>
<p>使用 scalac 进行编译生成 <code>HelloWorld.class</code> 文件；</p>
<pre><code class="language-scala">scalac HelloWorld.scala
</code></pre>
<p>最后若要运行，执行 <code>scala HelloWorld</code> ,控制台输入 <code>HelloWorld</code> 就说明运行成功了。</p>
<figure data-type="image" tabindex="7"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3upkz8bm3j311s04uq31.jpg" alt="HelloWorld"></figure>
<p>看过最简易的两种 Scala 版 HelloWorld 之后，我们开始学习一下 Scala 基础语法和特性吧。</p>
<h2 id="scala-语法">Scala 语法</h2>
<h3 id="变量">变量</h3>
<p>Scala 声明变量的关键字有两个：<code>var</code> &amp; <code>val</code>。 <code>var</code> 用于可变变量的声明，是 <code>variable</code> 的简写；<code>var</code> 用于常量的声明，是 <code>value</code>的简写。下面是一般的写法，定义的变量名与类型之间，需要用一个冒号<code>:</code> 隔开。</p>
<pre><code class="language-sql">val x: Int = 1+1
var y: String = &quot;abc&quot;
</code></pre>
<blockquote>
<p>Scala 中允许不使用分号表示语句结束，换行即认为新语句的开始</p>
</blockquote>
<p>但与 Java 声明变量时必须要指定变量类型不同， Scala 具有类型推断的特性，就不需要显示地声明类型,因此我们可以写成下面形式：</p>
<pre><code class="language-scala">val x = 1+1
var y = &quot;abc&quot;
</code></pre>
<p>现在再来说下 <code>var</code> 与 <code>val</code> 的区别：<code>val</code> 用于声明的常量，当赋值之后就不能再改，尝试修改值时会编译错误。</p>
<figure data-type="image" tabindex="8"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3tm3vlukwj311s09i74v.jpg" alt="carbon"></figure>
<p>另外，<code>val</code> 变量赋值为一个引用对象时，可以改变对象的属性，但不能再指向其他对象，所以 <code>val</code>可以理解为 Java 中用 <code>final</code> 修饰的变量。</p>
<h3 id="数据类型">数据类型</h3>
<p>在 Scala 中一切都是对象，首先看下官方提供的 Scala 类型层次图，有跟 Java 相同的数据类型，也有 Scala 特有的类型。</p>
<figure data-type="image" tabindex="9"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3tmg50zavj314r0d3gnc.jpg" alt="Scala 类型层次图"></figure>
<p>Java 中有八大基础数据，Scala 则有九个基础数据类型， 除了一样有 <code>Double</code>，<code>Float</code>，<code>Long</code>，<code>Int</code>，<code>Short</code>，<code>Byte</code>，<code>Boolean</code>，还额外多一个 <code>Unit</code> 类型，它表示不带任何意义的类型，有且仅有一种值：<code>()</code> ，可以理解为 Java 中的 <code>void</code>，在函数定义时使用表示该函数无返回值。</p>
<p>这些基础类型都有一个父类 <code>AnyVal</code>，它表示通用的值类型，与 <code>AnyVal</code>相对的就是引用类型 <code>AnyRef</code>, Scala 中的集合对象（<code>Set</code>，<code>Map</code>），字符串类(<code>String</code>) ，以及自定义的类则都属于 <code>AnyRef</code>，相当于 Java 中的 <code>java.lang.Object</code>。</p>
<p>在 <code>AnyVal</code> 和 <code>AnyRef</code> 之上的就是 Scala 最顶级的类型 ，它定义了一些最通用的方法如 <code>equals</code>，<code>hashCode</code> 和 <code>toString</code>。</p>
<h4 id="nothing-和-null">Nothing 和 Null</h4>
<p>Scala 类型层次图底部还有两个类型 <code>Nothing</code> 和 <code>Null</code>，<code>Nothing</code>是所有类型的子类型，该类型下没有任何一个值，主要用于程序的异常和中断的非正常返回；而 <code>Null</code> 为引用类型的子类型，只有一个值：<code>null</code> ，主要是在与 Java 交互时使用。</p>
<h4 id="值类型转换">值类型转换</h4>
<p>不同的值类型，Scala 也支持类型转换，并且是单向的,下面是值转换的方向图。</p>
<figure data-type="image" tabindex="10"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3tng1yu8vj30j604tglq.jpg" alt="值类型转换"></figure>
<p>而如果尝试非指定方向的类型转换，就不会通过编译，直接提示错误： <code>type mismatch</code>，如下示例：</p>
<figure data-type="image" tabindex="11"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3tnn55trcj311s0ni0ue.jpg" alt="mismatch"></figure>
<h3 id="方法函数">方法/函数</h3>
<p>在 Scala 中方法和函数通常情况下可以认为是一个东西，只是函数可以作为变量单独使用，可以理解为 Java8 的 Lambda 表达式，首先来看下他们如何定义，这一点跟 Java 还是有很大不同的。</p>
<figure data-type="image" tabindex="12"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3tpb6vhkbj311s0fcjsl.jpg" alt="方法/函数"></figure>
<p>上面是函数/方法最简化的定义方式，针对单行的表达式，Scala 是允许省略大括号和 <code>return</code> 关键字的。</p>
<p>首先看下函数的定义，<code>=&gt;</code> 左边为参数列表(这里的类型不能省略)，右边的为表达式内容，从上面的 <code>add</code> 函数变量类型输出可以看出 <code>add</code> 函数变量类型为 <code>(Int, Int) =&gt; Int</code>，底层是一个 Lambda 相关的对象。</p>
<blockquote>
<p>匿名函数,也叫做闭包：表示没有名字的函数，将定义的函数没有指定变量名称直接使用，如 <code>(x: Int) =&gt; x + 1</code></p>
</blockquote>
<p>Scala 定义方法需要使用 def 关键字，这是 Java 所没有的，并且 <code>def</code> 后面紧跟方法名称，参数列表，返回类型和方法体，下面给出常见的方法定义语法</p>
<figure data-type="image" tabindex="13"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3tpurahhtj311s076q3e.jpg" alt="定义方法"></figure>
<p>需要注意的是，<strong>在 Scala 方法中默认将最后一行的语句结果作为返回值</strong> 。（跟 Java 一样，Scala 也有 <code>return</code> 关键字，但为了简洁很少使用）。而如果方法定义返回值类型为 <code>Unit</code>时，则表示该方法没有返回值。</p>
<figure data-type="image" tabindex="14"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3tq03pc1kj311s060wep.jpg" alt="return"></figure>
<p>除此之外，如果调用的函数或者方法没有入参，可以把括号省略。</p>
<p>接下 Scala 函数/方法中所支持的一些特性：可变参数，默认参数，命名参数:</p>
<p>1.可变参数</p>
<p>Scala 允许指明函数的最后一个参数是可以重复的，在参数类型后面放星号 <code>*</code>，表示可重复的参数，Java 中使用 <code>...</code>：</p>
<figure data-type="image" tabindex="15"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3tqcy6z0rj311s08c0tj.jpg" alt="可变参数"></figure>
<p>同样函数内部用一个数组接收可变参数。</p>
<p>2.默认参数</p>
<p>Scala 允许为函数参数指定默认值，这样即使调用函数过程中不传递参数，函数就是采用它的默认参数值，如果传了参数，默认值就会被忽略，这一特性是 Java 所没有的,但使用起来也很方便简单。</p>
<figure data-type="image" tabindex="16"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3tqizldp7j311s08c74k.jpg" alt="默认参数"></figure>
<p>3.命名参数</p>
<p>尽管函数定义时指定了参数列表顺序，但是 Scala 支持不按照定义顺序，按照指定参数名字进行参数传递，实例如下：</p>
<figure data-type="image" tabindex="17"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3tqq3ljmoj311s0budgl.jpg" alt="命名参数"></figure>
<h3 id="流程控制">流程控制</h3>
<p>程序中通常涉及的流程控制主要两种：条件判断和循环处理。</p>
<h4 id="条件判断">条件判断</h4>
<p>条件判断上，Scala 有与 Java 一样的 <code>if-else</code> 语法，除此之外，Scala 提供了<strong>模式匹配</strong>的机制进行条件判断。</p>
<p>它是 Java 的 <code>switch</code> 语句的升级版，首先看下语法：</p>
<figure data-type="image" tabindex="18"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3ttacxntgj311s0aoglz.jpg" alt="模式匹配"></figure>
<p>这是使用新关键字 <code>match</code> , 左侧为被匹配的值，而右侧包含了四个 <code>case</code> 表达式，每个表示一种条件，最后的 <code>case _</code> 表示匹配其余所有情况，类似 <code>switch-case</code> 语法的 <code>default</code> 作用。</p>
<p><code>match</code> 表达式允许接受返回值，正如上方式示例会返回 <code>String</code> 类型，所以模式匹配通常定义在函数中，如下：</p>
<figure data-type="image" tabindex="19"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3ttfm3of9j311s0aoq3j.jpg" alt="模式匹配2"></figure>
<p>如果匹配的条件里要执行多个语句，则就需要使用大括号 <code>{}</code>包含了，需要注意的是模式匹配一旦某个条件匹配成功，就不会执行其他条件的语句，自带了 <code>break</code> 的效果。</p>
<p>Scala 的模式匹配在本文仅进行简单的用法演示，还有丰富的用法详细可见<a href="https://docs.scala-lang.org/zh-cn/tour/pattern-matching.html">官方文档-模式匹配一节</a></p>
<h4 id="循环处理">循环处理</h4>
<p>Scala 循环语法比较特别，使用 <code>for</code> + <code>&lt;-</code> 来进行遍历元素，并提供了便捷的 <code>until</code>方法，<code>to</code>方法来实现遍历, 需要注意的就是 <code>until</code>方法采用半闭区间，不包含索引最后一位。而 <code>until</code>方法，<code>to</code>方法底层都是构建 Range 对象然后进行遍历。</p>
<figure data-type="image" tabindex="20"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3tu3yt8lej311s0pu0ug.jpg" alt="Scala  循环"></figure>
<p>除了上面简单用法之外，在 <code>for</code> 循环中还可以配合 <code>if</code> 条件进行遍历过滤，如下面简单的示例，是不是很灵活呢。</p>
<figure data-type="image" tabindex="21"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3tudmenlvj311s076wep.jpg" alt="for"></figure>
<h3 id="类">类</h3>
<p>Scala 中类的概念与 Java 的基本一致，而语法形式和用法上更加丰富灵活。</p>
<p>先看下类的定义，没看错下面是 Scala 最简单的类的定义和使用了，创建了一个 <code>User</code> 对象，赋值给了 <code>user1</code> 变量。</p>
<figure data-type="image" tabindex="22"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3tv91crvej311s0600sr.jpg" alt="类的定义和使用"></figure>
<p><code>new</code> 关键字用于创建实例，由于当前 <code>User</code> 没有定义任何构造器，因此只有一个默认的无参构造器，可以直接省略括号<code>()</code>。</p>
<h4 id="构造器">构造器</h4>
<p>再看下一个带有自定义构造器的类如何定义，看起来是不是很奇怪，紧跟类名括号后面的就是构造器所需的参数。</p>
<figure data-type="image" tabindex="23"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3tvij2axfj311s08cwf8.jpg" alt="构造器"></figure>
<p>这里会有个疑问：如果有多个构造器函数，那这个类都该如何定义呢？来看下示例写法，基于原有构造器，用 <code>def this(...)</code>定义了一个新的方法，内部执行 <code>this(name，age)</code> 实际调用了原来的构造器。Scala 将这个定义方法称为辅助构造器，紧跟类名后的为主构造器。</p>
<figure data-type="image" tabindex="24"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3tvsr2vloj319k0ho0ul.jpg" alt="多个构造器"></figure>
<p>Scala 允许一个类有多个辅助构造器，但只能有一个主构造器，并且辅助构造器内部第一行必须调用主构造器，这里是可以通过多个辅助构造器间接地调用主构造器。</p>
<p>如果辅助构造器有额外的构造参数，则需要添加字段关联，不会像主构造器一样自动生成字段如上面 <code>Person</code> 类的 <code>name</code>和 <code>age</code>。</p>
<h4 id="成员变量和-gettersetter-语法">成员变量和 Getter/Setter 语法</h4>
<p>在 Java 开发中，通常我们会将 Java Bean 的成员变量私有化，然后提供 Getter/Setter 方法供外部操作该变量，那边在 Scala 类中有该如何操作呢，其实也很简单，首先看下示例。成员变量的成员默认是<code>public</code>的，可以使用<code>private</code>访问修饰符可以在函数外部隐藏它们。</p>
<figure data-type="image" tabindex="25"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3u18kjoc1j311s0iudht.jpg" alt="成员变量"></figure>
<p>注意这边字段声明时使用了 <code>_</code> 关键字,这个在 Scala 中表示特定类型的默认值，用于占位的作用，如果对于为 String 类型，则该值就是空字符串。</p>
<h4 id="继承重写">继承重写</h4>
<p>继承是面向对象语言的重要的特性之一，Scala 在继承方面也跟 Java 一样，使用 <code>extends</code> ，并且只允许单继承。继承情况有两种，一种为父类采用了默认构造器，另外一种就是父类有自定义的构造器，子类定义时必须满足父类构造器参数的要求，先会执行父类的主构造器，在执行子类自己的构造器。</p>
<figure data-type="image" tabindex="26"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3u1igr9krj314e0gitbq.jpg" alt="继承"></figure>
<p>当子类继承父类后，想要重写父类方法也十分简单，使用 <code>override</code> 关键字修饰需要重写的访问，子类默认执行父类方法例如这样的形式 <code>super.foo()</code>,我们只需调整为自定义的实现即可。</p>
<h4 id="trait">Trait</h4>
<p>Trait 翻译过来就是特征，特性的意思，看似比较新颖，其实它就类似于 Java 的接口，用于扩展我们的类。跟 Java 的 Interface 一样，Trait 也无法被实例化，通常提供若干个抽象方法和字段，由具体的类使用 <code>extends</code> 关键字实现。</p>
<p>有一点不同的是，当类需要实现多个 Trait 时，<code>extends</code> 只能指向一个 Trait，其余的 Trait 都需要使用 <code>with</code> 关键字 关联，如下方给出的示例。</p>
<figure data-type="image" tabindex="27"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3u1uo3daij311s076mxz.jpg" alt="Trait"></figure>
<h4 id="case-class">Case Class</h4>
<p>Case Class 是 Scala 特有的一种特殊的类，定义方式虽然跟普通类一样，但需要使用 <code>case class</code> 组合关键字修饰。主要用于不可变的数据和模式匹配中。</p>
<figure data-type="image" tabindex="28"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3u28gbcdej311s060jrw.jpg" alt="Case Class"></figure>
<p>实例化 Case Class 类时不需要使用 <code>new</code> 关键字，而是有一个默认的<code>apply</code>方法来负责对象的创建。并且赋值字段都是默认用<code>public val</code>修饰，让字段不可更改。</p>
<p>额外注意的是当两个 Case Class 对象进行 <code>==</code> 比较的时候，Scala 是按照值比较，而不是引用比较。</p>
<h4 id="单例对象">单例对象</h4>
<p>Scala 将单例对象单独用 <code>object</code> 关键字单独声明出来，定义方式用类一样, 如 <code>object Box</code>。但单例对象也是属于一种特殊的类，有且只有一个实例，并且当它第一次被使用时才会创建。</p>
<p>伴生对象与伴生类</p>
<p>Scala 允许一个单例对象与某个类共用一个名称，而这样两者形成了伴生的关系，单例对象成为该类的伴生对象，而类成为单例对象的伴生类。伴生的关系主要体现在于，伴生对象里定义的成员，可以在伴生类上使用，这一点就是好比在 Java 中 <code>static</code> 成员。</p>
<figure data-type="image" tabindex="29"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3u55bv6ryj311s0iuwg5.jpg" alt="carbon"></figure>
<h4 id="tuple-元组">Tuple 元组</h4>
<p>元组也属于 Scala 中一个特殊的类，它允许包含不同类型的元素，并且为不可变。常见的用法就是当我们需要函数返回多个值时，这点就可强大了。</p>
<p>首先看下元组的创建和使用</p>
<figure data-type="image" tabindex="30"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3u5fmjg7cj311s060wey.jpg" alt="Tuple"></figure>
<p>Tuple2 类属于 Scala 定义的元素类，从 <code>Tuple2</code>...<code>Tuple22</code> 一共有 21 个这样类，每个类表示当前所对应的参数个数，也就是元组中最多包含 22 个参数。</p>
<p>元组访问起来也很方便，用<code>tuple._n</code>方式去取第 n 个元素。</p>
<h3 id="集合">集合</h3>
<p>除了兼容 Java 的集合框架，Scala 还提供了丰富强大的集合类，我们主要来学习下 Scala 中最常用的几种集合。</p>
<h4 id="set">Set</h4>
<p>一种不包含重复元素的容器对象，分为不可变 Set 和可变 Set 两种，默认为不可变。</p>
<figure data-type="image" tabindex="31"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3u4uod1vuj311s0e6765.jpg" alt="Set"></figure>
<p>不可变 Set 常用的操作方法有</p>
<ul>
<li><code>xs.contains(x)</code>，<code>xs(x)</code> 判断集合是否存在该元素</li>
<li><code>xs intersect ys</code>，<code>xs &amp; ys</code> 两个集合取交集</li>
<li><code>xs union ys</code>，<code>xs | ys</code> 两个集合取并集</li>
<li><code>xs diff ys</code>，<code>xs &amp;~ ys</code> 两个集合取差集</li>
</ul>
<p>可变 Set 常用的操作方法有</p>
<ul>
<li><code>xs add x</code> 添加到集合</li>
<li><code>xs remove x</code> 从集合中移除</li>
<li><code>xs.clear()</code> 清空集合</li>
<li><code>xs(x) = b</code> ，<code>xs.update(x, b)</code> 将集合更新</li>
</ul>
<h4 id="map">Map</h4>
<p>Map 集合特点就是以键值对结构存储。使用语法上有两种：</p>
<ul>
<li><code>key -&gt; value</code> 方式添加元素</li>
<li><code>(key, value)</code> 方式添加元素</li>
</ul>
<p>Map 集合与 Set 集合类似，也有不可变和可变之分，默认为不可变。</p>
<figure data-type="image" tabindex="32"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3u59dhi2cj315s0iudij.jpg" alt="Map"></figure>
<p>常用的 Map 操作有</p>
<ul>
<li><code>map.keys</code> 返回含有所有 key 的可迭代对象</li>
<li><code>map.keySet</code>返回一个含所有 key 的集合</li>
<li><code>map.values</code> 返回一个含所有 value 的可迭代对象</li>
<li><code>map(k) = v</code> 更新元素</li>
<li><code>map.put(k, v)</code> 新增元素</li>
<li><code>map.remove(k)</code> 移除元素</li>
<li><code>map.clear()</code>清空 Map 集合</li>
</ul>
<h4 id="数组">数组</h4>
<p>Scala 数组与 Java 数组是一一对应的。同样把 Array 作为数组的标识符，下面先看下如何声明一个定长数组和简单使用。</p>
<figure data-type="image" tabindex="33"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3tsd0dd6fj311s0budgz.jpg" alt="定长数组"></figure>
<p>访问数组指定元素时采用括号+索引的形式，当数组元素没有值时，用 <code>null</code> 表示。</p>
<p>Scala 除了定长数组之外，还提供了可变数组的实现 <code>ArrayBuffers</code>，这个 Scala 提供的可变容器的一种数组实现，能直接访问和修改底层数组，具体使用方式如下：</p>
<figure data-type="image" tabindex="34"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3tsp6nu42j311s0iu0v2.jpg" alt="Array Buffers"></figure>
<blockquote>
<p>Scala 提供了许多可变容器集合，如 ArrayBuffer，ListBuffer，链表，队列等等，都封装在 <code>scala.collection.mutable.*</code> 包下。</p>
</blockquote>
<p>使用数组就会有越界访问的情况，当 Scala 数组出现越界访问时，抛出 <code>java.lang.IndexOutOfBoundsException</code>异常。</p>
<figure data-type="image" tabindex="35"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3tt3jmy9lj311s09i75x.jpg" alt="越界访问"></figure>
<h2 id="scala-实战scala-spring-boot">Scala 实战：Scala + Spring Boot</h2>
<p>接触了那么多 Scala 语法和特性之后，我们通过用 Scala 语言来编写简单的 Spring Boot Web 应用访问 hello 请求，来看下它是如何跟 Java 混合开发的。</p>
<p>我们使用 IDEA 作为开发工具，要使用 Scala 语言，为了让 IDE 提供更好的 Scala 语言支持，可以先安装 Scala 插件</p>
<figure data-type="image" tabindex="36"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3u5uhfsy2j31h20a8757.jpg" alt="Scala 插件"></figure>
<p>我们可以通过 https://start.spring.io/ 创建一个普通的 SpringBoot 项目，下载到本地后解压用 IDEA 打开。</p>
<p>基于原来的目录接口，新建一个 scala 源代码目录。</p>
<figure data-type="image" tabindex="37"><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3u66jym8dj30c80860t0.jpg" alt=" scala 源代码目录"></figure>
<p>Scala 的源代码目录创建后，转到 Pom 文件，修改 XML 配置：</p>
<ol>
<li>
<p>首先引入 Scala 语言库, 这里版本为 2.12.8<img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3u60fb7cbj311s08c0tg.jpg" alt="Scala 语言库"></p>
</li>
<li>
<p>加入 Scala 依赖包之后，我们还需要添加一个用于编译 Scala 的 Maven Plguin。<img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3u64hijmyj30u00yftc9.jpg" alt="Maven Plguin"></p>
</li>
</ol>
<p>好了，到此 Scala 的项目配置已经完成，接下来就可以编写 Scala 代码了。</p>
<blockquote>
<p>为了接受 hello 请求，项目 POM 先别忘了依赖 <code>spring-boot-starter-web</code></p>
</blockquote>
<p>新建一个 Scala 类 <code>HelloContrroller.scala</code>，实现一个接受 <code>/hello</code> 请求的方法，如下<img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3u69ipzypj311s0iu75t.jpg" alt="HelloContrroller.scala"></p>
<p>然后直接启动项目引导类 <code>com.blog4one.learn.ScalaActionsApplication</code>，启动日志如下则表示启动成功，默认服务监听 8080 端口。</p>
<figure data-type="image" tabindex="38"><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3u6c4q5k7j319i0u0ag8.jpg" alt="启动日志"></figure>
<p>打开浏览器，输入 <code>http://localhost:8080/hello</code>，回车即可看到结果。</p>
<figure data-type="image" tabindex="39"><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3u6eeaaq1j30fc062t8s.jpg" alt="image-20190608234156015"></figure>
<p>浏览器成功的响应，也说明了 Scala 编写的 <code>HelloContrroller.scala</code> 能接受并处理响应，而底层仍然是基于 Java 框架 Spring Boot 构建。</p>
<h2 id="结语">结语</h2>
<p>好了，基本的 Scala 语法和特性先介绍到这里，通过这次学习想必也看到了 Scala 虽然是基于 JVM 上运行，但是语法和功能都极其灵活，想要掌握还需要花一定精力时间， 后续继续对 Scala 高级特性和用法进行介绍，感兴趣的小伙伴可以关注我的微信公众号，会在第一时间更新哈。</p>
<h2 id="参考">参考</h2>
<ul>
<li>Scala 之百度翻译： https://fanyi.baidu.com/?aldtype=16047#en/zh/Scala</li>
<li>Introduction to Scala：https://www.baeldung.com/scala-intro</li>
<li>从 Java 到 Scala，再到 Kotlin：https://juejin.im/post/5cf091e9f265da1bbb03c0c7</li>
<li>Scala - 维基百科，自由的百科全书：https://zh.wikipedia.org/wiki/Scala</li>
<li>Scala repl overview: https://docs.scala-lang.org/overviews/repl/overview.html</li>
<li>Learn Scala in Y Minutes：https://learnxinyminutes.com/docs/zh-cn/scala-cn/</li>
<li>GETTING STARTED WITH SCALA IN INTELLIJ：https://docs.scala-lang.org/getting-started-intellij-track/getting-started-with-scala-in-intellij.html</li>
<li>TOUR OF SCALA：https://docs.scala-lang.org/tour/tour-of-scala.html</li>
<li>Scala 课堂：https://twitter.github.io/scala_school/zh_cn/index.html</li>
<li>Scala 开发者的 SpringBoot 快速入门指南：https://afoo.me/posts/2015-07-21-scala-developers-springboot-guide.html</li>
</ul>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://wrcj12138aaa.github.io//tag/llypUO29A">
            <span class="flex-auto">Java</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://wrcj12138aaa.github.io//tag/6yxYqQsgID">
            <span class="flex-auto">Scala</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://wrcj12138aaa.github.io//post/20190616-Java微服务新生代之Nacos">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  Java微服务新生代之Nacos
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://wrcj12138aaa.github.io//post/20190602-Java必备之Lombok必知必会">
                <h3 class="post-title">
                  Java必备之Lombok必知必会
                  <i class="remixicon-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        

      </div>
    </div>

    <script src="https://wrcj12138aaa.github.io//media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
